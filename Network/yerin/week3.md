# 네트워크 3주차
https://hyper-hotel-11e.notion.site/3-b7fe25e9a1464e0ea6e7367c59099129?pvs=4

# 📌Router & Routing

Network Layer의 핵심 : Routing & Forwarding

== 라우터의 역할

### **Routing**

 "어디로 가야 하는가?"

라우팅은 네트워크의 여러 경로 중에서 특정 목적지로 데이터 패킷을 보내기 위한 최적의 경로를 결정하는 과정

⇒ **라우팅 알고리즘**에 의해 결정됨

global & static ⇒ link state 알고리즘

- 모든 라우터가 모든 연결사항을 알 때
- 전체 구조와 링크 상태 파악
- 변화가 아주 느리게 발생
- 문제 발생 시 전체 정보를 알기 때문에 문제 지점만 제거하면 됨

decentralized & dynamic ⇒ distance vector 알고리즘

- 이웃의 정보만 공유
- 각 router가 알아서 처리
- 다소 변화가 빠름
- 이상한 정보를 믿고 전파할 수도 있음

### **Forwarding**

 "이 패킷을 어떻게 그곳으로 보내는가?"

포워딩은 라우터가 라우팅 테이블의 결정에 따라 실제로 데이터 패킷을 다음 홉(다음 네트워크 장비로 이동) 또는 최종 목적지로 전달하는 과정

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%203%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20b7fe25e9a1464e0ea6e7367c59099129/Untitled.png)

# 📌DHCP

host는 어떻게 ip주소를 얻지?

DHCP로.. 동적으로 서버로부터 주소를 얻을 수 있음

⇒ 재사용 가능 

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%203%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20b7fe25e9a1464e0ea6e7367c59099129/Untitled%201.png)

과정

1. 호스트가 ‘DHCP discover’ msg를 broadcast 함
2. dhcp 서버가 “DHCP offer’ msg 응답
3. host가 “DHCP request’ msg로 ip 주소 요청
4. DHCP 서버가 “DHCP ack” msg로 주소 응답

DHCP가 돌려주는 것

- IP주소 할당
- first-hop router(인터넷으로 나가기 위한 첫 관문)의 주소
- DNS 서버의 이름과 IP주소
- network mask ( == subnet mask)

> 공유기 = 라우터의 기능을 포함한 장치
일반 가정집에서는 공유기가 DHCP서버를 탑재하고 있어서
이 경우에는 HOST(기기)와 공유기가 통신을 하면서 IP주소를 할당 받고 First-hop-router의 주소 정보는 곧 DHCP서버(공유기)의 주소 정보가 됨.
그런데 큰 조직이나 기업 환경에서 사용되는 고급 라우터들은 네트워크 구성이 복잡해서 DHCP 서버 기능은 별도의 전용 서버에 의해 처리하는 경우들이 있음. 이럴 때는 First-hop-router와 DHCP서버 주소가 다름.
> 

# 📌NAT(Network Address Translation)

NAT는 IPv4의 주소 부족 문제를 해결하기 위한 하나의 간접적인 방법으로,

주로 사설 네트워크 주소를 사용하는 망에서

외부의 공인 망(예를 들면 인터넷)과의 통신을 위해서 네트워크 주소를 변환하는 것.

즉 내부 망에서는 사설 IP 주소를 사용하여 통신을 하고, 

외부 망과의 통신 시에는 NAT를 거쳐 공인 IP 주소로 자동 변환됨.

과정

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%203%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20b7fe25e9a1464e0ea6e7367c59099129/Untitled%202.png)

<aside>
💡 위 방식은 먼저 내부에서 요청을 보내면서 라우터가 출발지를 기억하기 때문에 다시 데이터를 돌려줄 수 있는데, 만일 내부에서 먼저 요청을 보낸 게 아니고 냅다 외부에서 내부로 연결을 하고싶어할 땐 어떻게 수많은 내부 기기 중 하나를 찾아낼 수 있을까?

</aside>

### Port Forwarding

별도의 설정이 없다면,

외부 아이피가 접속을 시도해올 때, 내부의 어떤 프로세스(서비스) 또는 기기와 연결할 지 알 수 없어서 접근이 불가능하다.

그래서 특정 프로세스(서비스) 또는 기기에 접근하기 위해 

포트 포워딩을 통해 `외부 아이피 : 특정 포트` 가 접속하면 `내부 아이피 : 특정 포트`로 맵핑해준다.

> 예를 들어서..
집에서 내가 서버를 하나 켜놨음.
외부에서 접속 가능하게 하고싶음.
근데 우리집 공유기에 연결된 기기 5개임.
포트포워딩 없이는 외부에서 서버를 켜놓은 내 기기를 찾아올 수 없음.
그래서 외부에서 IP주소:8080 포트로 요청을 보내면 무조건 내 기기로 오도록 포트포워딩함.
외부에서 우리집 공유기의 공인 IP 주소와 8080번 포트로 웹 요청을 보냄
공유기는 이를 내부 네트워크의 웹 서버 IP 주소와 포트로 포워딩함.
연결 완료
> 

# 📌Link Layer

- Frame 단위
- 안전한 통신의 흐름을 관리
- 에러검출, 에러 수정, 흐름 제어 수행
- 스위치, 이더넷

## Error Check

- Parity checking 방식 - single bit error
- Cyclic redundancy check 방식 - burst errors

## MAC  addr & ARP

### **MAC addr**

IP 주소는 네트워크 계층(Network Layer)에서 사용되는 주소다. 

MAC 주소는 데이터 링크 계층에서 사용되고, LAN에서 목적지와 통신하기 위한 실질적인 주소이다.

48bit (16진수) 

MAC주소 = unique한 주민번호 / Portability (LAN 카드 옮기면 됨)

IP주소 = 우편주소 

<aside>
💡 그럼 IP 주소 대신 MAC 주소만 사용하면 안 되나?
⇒ 만약 MAC 주소만 사용한다면, 라우팅 테이블에 너무 많은 정보가 기록되어 다운될거임. 
(라우팅 테이블에서는 IP주소 범위를 사용하니까)

</aside>

### ARP (Address Resolution Protocol)

네트워크 상에서 IP 주소를 MAC 주소로 대응시키기 위해 사용되는 프로토콜

IP 주소와 MAC 주소를 일대일 매칭 시켜 LAN에서 목적지를 찾아갈 수 있도록 해줌.

모든 host와 router는 ARP Table을 가짐

ARP table - IP주소, MAC주소, TTL 정보를 대응시켜 정리한 테이블

**1️⃣ ARP - 같은 LAN** 

예시) A가 B에게 datagram을 보내려함.

1. A는 B의 IP주소는 알지만 MAC주소는 모름
2. A가 ARP 쿼리(A의 MAC주소 + B의 IP주소)를 broadcast함
3. B가 받으면 A한테 자신의 MAC주소를 반환 (Unicast로 A에게만)
4. A는 ARP table에 IP-MAC pair 저장
5. 이제 A는 B의 IP주소와 MAC주소를 아니까 보내기만 하면 됨

2️⃣ **ARP - 다른 LAN** 

예시) A가 R을 거쳐 B에 datagram을 보내려함.

1. 다른 LAN임을 파악 ⇒ src(dest) IP &(op) subnet-mask = net ID / src와 dest net ID비교
2. A는 B의 IP주소 알고, DHCP를 통해 R의 IP주소도 알고, same LAN ARP를 통해 R의 MAC주소도 안다.
3. A는 IP datagram 생성 (src IP, dest IP)하고, 이게 link layer에서 encapsulate하고 header에는 A의 MAC주소와 DEST로는 R의 MAC주소를 포함해서 frame을 생성함
4. LINK layer에서 A가 R로 전송됨
5. R은 받은 Frame의 헤더를 벗기고 net layer에서 datagram을 확인하고 최종 dest IP 확인
6. R은 ARP를 통해 B의 MAC 주소를 알아내 DEST MAC으로 두고 다시 frame 생성해서 보냄 

## Ethernet

하나의 인터넷 회선에 다수의 시스템이 유/무선 통신장비 공유기, 허브 등을 통해

랜선 및 통신 포트에 연결되어 통신이 가능한 네트워크 구조

- 전세계 학교, 가정, 사무실에서 가장 많이 활용되는 네트워크 규격
- CSMA / CD방식
    
    회선에서는 아주 짧은 시간동안 데이터 송/수신을 제어 및 처리함.
    
    1. 보내는 사람은 케이블의 신호와 이력을 확인
    2. 다른 사람에게 신호가 흐르고 있지않음을 확인 후 전송
    3. 전송 중에도 파형에 의해 다른 사람의 송신과 충돌하지 않는지를 감시
    4. 만약 충돌발생 ⇒ 일정량 전송 후 중단하고, 일정 시간의 딜레이를 두어 전송을 재시작

## Switch

Ethernet을 사용하여 네트워크 내에서 데이터를 효율적으로 전송하는 데 사용되는 물리적 장치

- MAC주소에 맞게 Frame 전송
- Forwarding Table 가짐 (Mac 주소 - Interface - ttl 대응)
- Self-learning (어떤 host가 어떤 Interface를 사용했는지 알아서 인지)

Switch의 Self-learning & Forwarding 과정 예시

![Untitled](%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%E1%85%AF%E1%84%8F%E1%85%B3%203%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20b7fe25e9a1464e0ea6e7367c59099129/Untitled%203.png)

# **📌Physical Layer**

- 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 **물리적인 장비**
- 단지 데이터 전기적인 신호(0,1)로 변환해서 주고받는 기능만 할 뿐
- 통신 단위 : **비트(Bit) /** **1과 0 으로 표현됨** (On, Off 상태)
- 통신 케이블, 허브 등

# 📌WEB 통신 흐름

### 구글페이지에 접속하는 과정

- 인터넷 연결 - DHCP(IP주소 할당)
    1. 접속하는 노트북은 IP주소 필요 
    2. DHCP - UDP - IP - ETH 로 이루어진 frame을 DHCP request
    3. broadcast ⇒ DHCP 서버가 받음
    4. 서버측에서 Demuxed 함
    5. DHCP ACK [ client IP주소, first-hop-router IP주소, DNS name & IP주소 ] 생성
    6. 다시 encapsulate 하고, self-learning한 스위치를 통해 client에게 전달 ⇒ client demuxed
    7. client는 성공적으로 DHCP ACK를 받아 IP주소를 할당받음
- 구글 주소 파악 - APR / DNS / 라우팅 프로토콜
    1. DNS서버는 LAN에 있지 않으므로 라우터를 거쳐야함. 이 말은 즉슨 Frame을 라우터로 보내야하고 그럴거면 mac dest addr이 라우터의 mac addr이어야하니 APR 필요 
    2. DNS-UDP-IP-ETH로 encapsulate된 DNS 쿼리 생성 (아직 전송 못함)
    3. client가 라우터 IP주소 정보를 담은 ARP query를 broadcast함. (이때, DHCP에 의해 first-hop-router의 IP주소를 알고 있는 상태)
    4. 해당 라우터가 받아서 MAC주소를 ARP reply함.
    5. 이제 MAC주소도 알았으니 DNS 쿼리를 포함한 frame을 전송할 수 있게됨.
    6. 라우터에서 라우팅 프로토콜에 의해 라우트된 path로 포워딩되어 DNS서버에 접근
    7. DNS 서버측에서 demuxed 하고 구글의 IP주소를 응답으로 client에게 보내줌
    8. 성공적으로 그 응답을 client가 받아 구글 주소를 알게 됨
- TCP 3WAY handshaking
    1. client - TCP socket OPEN
    2. TCP SYN segment를 서버에게 보냄
    3. 서버는 TCP SYNACK을 보냄
    4. TCP 연결 완료
- HTTP 요청, 응답
    1. TCP socket을 통해 HTTP 요청 보냄
    2. 요청을 포함하고있는 datagram이 구글서버에 route됨
    3. 구글서버가 웹페이지를 HTTP reply로 응답보냄
    4. datagram이 client에게 route됨 
    5. 이제 웹페이지가 보임

# 📌로드밸런싱

 

둘 이상의 CPU 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것

요즘 시대에는 웹사이트에 접속하는 인원이 급격히 늘어나게 되었다.

따라서 이 사람들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버가 나눠서 일하도록 만드는 것(Scale-out)이 있다. 하드웨어 향상 비용이 더욱 비싸기도 하고, 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 바로 **로드밸런싱**이다.

**로드밸런싱**은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식이다. 서비스를 운영하는 사이트의 규모에 따라 웹 서버를 추가로 증설하면서 로드 밸런서로 관리해주면 웹 서버의 부하를 해결할 수 있다.

### 로드 밸런서가 서버를 선택하는 방식

- 라운드 로빈(Round Robin) : 서버로 들어온 요청을 순서대로 돌아가며 배정하는 방식
- Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)
- IP Hashing : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)
- Least Response Time : 가장 짧은 응답 시간을 보내는 서버로 트래픽을 할당하는 방식
- Bandwidth : 서버들과의 대역폭을 고려하여 서버에 트래픽을 할당

### **L4 로드 밸런서**

네트워크 계층이나 전송 계층의 정보를 바탕으로 로드를 분산

즉, IP 주소, 포트번호, MAC 주소, 전송 프로토콜 등에 따라 트래픽을 분산

- 패킷의 내용을 확인하지 않고 로드를 분산하므로 속도가 빠르고 효율이 높음.
- 데이터의 내용을 복호화할 필요가 없기에 안전.
- L7 로드밸런서보다 가격이 저렴.

### **L7 로드 밸런서**

어플리케이션 계층에서 로드를 분산

HTTP 헤더, 쿠키 등과 같은 사용자 요청을 기준으로 특정 서버에 트래픽을 분산

L4 기능 + 패킷의 내용을 확인하고 그 내용에 따라 로드를 특정 서버에 분배

- 캐싱(Cashing) 기능을 제공.
- L4 로드밸런서에 비해 비쌈. (패킷의 내용을 복호화하여야 하므로)
- 공격자가 로드밸런서를 통해 클라이언트의 데이터에 접근할 수 있는 보안상의 위험성 존재

- ⭐ CORS와 해결 방법을 말씀해주세요.
    
    cors란 교차 오리진을 허용해주는 정책으로, client와 server의 origin이 다를 때 리소스 공유를 허용해주는 정책입니다. 기본적으로는 sop정책에 의해 같은 오리진일때에만 리소스를 공유할 수 있도록 브라우저에서 막고 있지만, cors정책을 잘 이용한다면 다른 오리진에서도 리소스를 공유할 수 있게 됩니다. 
    
    가장 기본적인 방법으로는 서버측에서 응답 헤더의 access control allow origin값에 허용된 출처 값을 설정해주는 방식이 있습니다. 또한 서버와 클라이언트가 로컬호스트를 사용하고 있는 개발환경에서 클라이언트 측이 webpack devserver proxy 설정에서 프록싱을 통해 CORS 정책을 우회하는 방식도 있는데요. 예를들어 클라이언트가 localhost:3000이고 서버가 localhost:8080일때,
    클라이언트가 proxy 서버주소를 localhost:8080으로 설정해놓으면 클라이언트에서 api로 보내는 요청은 주소를 8080으로 바꿔서 보내겠다 라는 뜻이 되면서 마치 CORS 정책을 지킨 것처럼 브라우저를 속이면서도 우리는 원하는 서버와 자유롭게 통신을 할 수 있습니다.
    

- ⭐ 쿠키와 세션 차이에 대해 설명해주세요.
    
    HTTP 프로토콜은 **Connectionless**하고, 상태정보를 유지하지 않는(**Stateless**) 특징이 있습니다. 이러한 특징 덕분에 리소스의 낭비를 크게 줄여주지만, 매 통신마다 클라이언트가 인증을 필요로하게 됩니다. 쿠키와 세션은 이 단점을 보완하는 기술입니다.
    
    두 기술의 가장 큰 차이는 저장 위치로, **쿠키는 클라이언트에 세션은 서버에 저장**됩니다. 그래서 쿠키는 빠르지만 보안이 취약하게 되고, 세션은 느리지만 상대적으로 보안성이 좋습니다. 또 쿠키는 브라우저가 종료되어도 남아있게 되고, 세션은 삭제된다는 차이도 있습니다.
    
    일반적으로 **보안성이 중요할 때는 세션**을, **종료 시에도 유지되도록 하려면 쿠키**를 사용하는 등 두 기술을 병행해서 활용하게 됩니다. 이때 세션의 경우 서버 자원을 사용하게 된다는 점에서 사용자가 많아지면 자원 관리면에서 문제가 발생하니 유의해야 하기도 합니다. 따라서 쿠키와 세션을 적절한 요소 및 기능에 사용할 수 있어야 서버 자원의 낭비를 막고 웹사이트의 속도를 높일 수 있습니다.
    
