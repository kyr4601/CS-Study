## 네트워크가 뭐지요?

네트워크는 유선 또는 무선으로 여러 컴퓨터들을 연결하는 것을 의미한다. 어릴적 스타크래프트를 한 사람들은 LAN이라는 용어가 익숙할 것이다. LAN은 지역 네트워크를 이용하는 것으로, 지역망을 구축하기만 하면 인터넷을 통하지 않고도 컴퓨터끼리 통신하여 게임을 즐길 수 있었다. 사실 우린 어릴적 의식하고 사용하지 않았지만, 스타크래프트는 네트워크에 대하여 노골적으로 전문적인 이해를 요구했던 것 같다.

![](https://img1.daumcdn.net/thumb/R1280x0.fjpg/?fname=http://t1.daumcdn.net/brunch/service/user/cTd9/image/bkGwRJIhnIBOJ4tngA3k7LSVgos.jpg)

이처럼 LAN은 가정이나 회사 등 특정 영역에 존재하는 컴퓨터를 연결하는 네트워크를 의미하고, 이러한 LAN을 연결하는 걸 Wide Area Network라 하여 WAN이라고 한다. 정말 정말 대부분의 경우에는 인터넷을 이용하여 WAN을 연결한다.

## 서버와 클라이언트

네트워크는 한마디로 통신이기 때문에, 두 컴퓨터가 등장해야 한다. 우리는 일반적으로 통신하는 두 컴퓨터를 서버와 클라이언트라는 개념으로 표현한다. 이에 대하여 간단하게 좀 더 이해해보자. 

서비스를 제공하는 프로그램이 서버(server)이며 이를 수행하는 컴퓨터가 서버 컴퓨터이다. 우리가 생각하는 서버는 보통 아래 사진과 같은 공간에 잔뜩 있는 컴퓨터 자체를 의미하지만, 엄밀하게 말하면 그 컴퓨터들이 구동하는 "서비스를 제공하는 프로그램"이 서버다.

![](https://cdn.mos.cms.futurecdn.net/b651993fc051d5c7706386838b1559c6.jpeg)

그럼 클라이언트는 뭘까? 바로 우리, 즉 서비스를 받을 고객님이다. 정확히는, 서비스를 요청하는 프로그램을 클라이언트(client)라고 말한다. 일반적으로 우리는 클라이언트의 입장에서 브라우저(클라이언트 프로그램)나 카카오톡과 같은 메신저 앱(클라이언트 프로그램)을 통해 네이버, 카카오, 구글 등에 검색이나 메시지 서비스를 요청하고 제공받는 개념이라고 생각하면 된다.

기본적으로 클라이언트가 특정 서비스를 요청하면 서버는 해당 요청을 처리하고 처리 결과를 응답해주는 방식으로 통신이 이루어진다.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/1200px-Client-server-model.svg.png)

## OSI 7 Layer를 통해 통신 과정 들여다보기

자, 단순하게는 클라이언트가 서버에 요청하면, 서버가 해당 요청에 대한 응답을 준다는 것 까지는 이해했다. 그렇다면 예시 코드를 통해 도대체 어떤 일이 발생하는지 논리적인 단계별로 쪼개어 확실하게 이해해보자.

구글 검색창에 "Google"이라고 검색하는 상황을 가정해보자.

![](https://upload.wikimedia.org/wikipedia/en/8/87/Google_Search_error_of_January_31%2C_2009.png)

우리 클라이언트는 단순하게 구글이라는 메인 페이지에서 Google이라고 문자열을 입력한 뒤, 검색 버튼을 누르기만 하면 된다. 그러면 이 요청에 대한 검색 결과를 구글에서 전달해 주는 것이다. 이 과정을 한번 분석해보자. 분석을 위해서는 OSI 7 Layer라는 것에 대하여 알아야 한다.

![](https://miro.medium.com/v2/da:true/resize:fit:853/1*7yPBGx_K8GymgeGfzhfznA.gif)

위 그림은 OSI 7 Layer에 대한 간단한 내용과, 이를 바탕으로 통신 과정을 설명하고 있는 그림이다. 먼저 과정을 이해하고 각 계층이 하는 일에 대하여 알아보자.

많은 분야가 그러하겠지만, 우리는 단순히 구글 검색창에 "Google"이라는 문자열을 입력하여 검색 버튼을 눌렀을 뿐이지만, 이 검색이라는 서비스 요청을 네트워크를 통해 전달하는 과정은 OSI 모델 기준으로 7단계를 거쳐 이루어진다.

OSI 7 Layer를 기준으로 내 컴퓨터에서 공유기(라우터), 그리고 상대 컴퓨터(서버 컴퓨터)까지 도달하는 과정을 이해해보자. (하나하나 작성하기에는 번거로우니 GPT4에게 물어봤다. 잘 알려준 것 같다.)

1. **내 컴퓨터**
    - **응용 계층**: 브라우저에서 "Google"을 검색하려는 요청이 생성됩니다.
    - **표현 계층**: 이 요청은 적절한 형식으로 변환(인코딩)됩니다.
    - **세션 계층**: 이 요청을 처리하기 위한 통신 세션(TCP 세션)이 생성됩니다.
    - **전송 계층**: 요청 정보를 세그먼트로 나누고, 이 때 TCP 헤더가 추가되며, 이 헤더에는 소스 포트와 목적지 포트 정보가 포함됩니다.
    - **네트워크 계층**: 세그먼트를 패킷으로 변환하고, 이 때 IP 헤더가 추가되며, 이 헤더에는 소스 IP와 목적지 IP 정보가 포함됩니다.
    - **데이터 링크 계층**: 패킷을 프레임으로 변환하고, 이 때 이더넷 헤더가 추가되며, 이 헤더에는 소스 MAC 주소와 목적지 MAC 주소(이 경우 라우터의 MAC 주소) 정보가 포함됩니다.
    - **물리 계층**: 프레임을 전기 신호로 변환하여 네트워크 케이블을 통해 라우터로 전송합니다.
2. **라우터**(공유기)
    - **물리 계층**: 라우터는 네트워크 케이블을 통해 전기 신호로 받은 데이터를 디지털 신호로 변환합니다.
    - **데이터 링크 계층**: 디지털 신호를 프레임으로 변환하고 MAC 주소를 확인합니다.
    - **네트워크 계층**: 프레임을 패킷으로 변환하고, IP 주소를 확인한 후 라우팅 테이블에 따라 패킷을 다음 목적지(구글 서버)로 전송합니다.
3. **구글 서버 컴퓨터**
    - **물리 계층 ~ 네트워크 계층**: 이 과정은 라우터에서의 수신 과정과 동일합니다.
    - **전송 계층**: 패킷을 세그먼트로 변환하고, 포트 번호를 확인하여 해당 서비스(웹 서버)로 전달합니다.
    - **세션 계층 ~ 응용 계층**: 세그먼트를 데이터로 변환하고, 웹 서버가 이를 처리하여 "Google" 검색 결과를 생성합니다.
4. **구글 서버 라우터**: 이 과정은 "내 컴퓨터"에서의 송신 과정과 동일하나, 이번에는 검색 결과를 포함하는 HTTP 응답이 전송됩니다.
    
5. **내 컴퓨터의 라우터**: 이 과정은 "라우터"에서의 수신 과정과 동일하며, 패킷이 내 컴퓨터로 전송됩니다.
    
6. **내 컴퓨터**: 이 과정은 "구글 서버 컴퓨터"에서의 수신 과정과 동일하나, 이번에는 HTTP 응답을 받아 웹 브라우저가 이를 처리하여 사용자에게 "Google" 검색 결과를 보여줍니다.

![](https://miro.medium.com/v2/resize:fit:828/format:webp/0*bcvf3Aqz0Ljxx8rL)

즉, 송신 과정에서는 위 사진의 application layer에서 physical layer로 내려갔다가 라우터로 보내고, 라우터는 보통 network layer, data link layer, physical layer로 구성되어 IP 주소를 바탕으로 다음 스위치나 라우터 MAC 주소를 갖고 길을 찾아갈 수 있게 해주며, 이런 과정을 여러번 거쳐 목적지 서버 프로그램까지 도착하게 되는게 데이터 전송 과정이다. 응답은 역순으로 보면 된다. 물론 한번 통신을 수립한 길은 해당 길 정보를 각 라우터가 기억하여, 나중에는 더욱 빠르게 통신이 이루어진다. 우리가 한번 가본 길은 익숙하게 가는 거랑 똑같다.

추가로, 각 레이어는 대표하는 프로토콜(Protocol)들이 있다. 여기서 프로토콜이란 통신 문법이라고 이해하면 된다. 우리가 한국어를 사용하여 대화를 할 때, 정해진 어순이 있듯이, 컴퓨터끼리도 전기 신호를 데이터화하여 통신하기 위해서는 일정한 규약을 바탕으로 통신을 하게 된다. 프로토콜에는 Application layer의 HTTP, Transport Layer의 TCP, Network Layer의 IP 프로토콜 등이 있다. 각 프로토콜은 독립적으로 골라먹는게 아니라, 유기적으로 연결되어 있다. 보통 TCP/IP는 묶어서 말하고, HTTP도 HTTP/1.1, HTTP/2 버전은 TCP기반으로 통신을 한다. 근데 [HTTP/3는 UDP 기반으로 통신을 한다](https://easy-code-yo.tistory.com/80)고 하니 이것도 알아두자. 

## TCP/IP Stack

사실 근데, 위 OSI 7 Layer보다는 실제로는 TCP/IP Stack이라고 부르는 통신 모델이 더 실질적으로 잘 와닿는 개념이라고 한다. 나 또한 이 의견에 동의한다. 레이어가 조금 더 뭉툭하게(?) 구분되어있긴 한데, 그렇기 때문에 좀 더 이해하기에 편안하고 통신을 이해하는 것에도 더 무난하게 느껴진다.

TCP/IP stack은 Application Layer, Transport Layer, Internet Layer, Link Layer 4가지로 분류한다. 

![](https://cheapsslsecurity.com/blog/wp-content/uploads/2022/06/tcp-ip-model-vs-osi.png)

OSI 모델을 이해했으니 이를 기준으로 이해하자면, 위와 같이 매핑된다. 각 역할은 매핑되는 개념으로 갈무리 할 수 있을 것 같고, 추가로 알아야 하는 건 여기서 TCP/IP stack의 application layer 부분이 유저모드 환경에서 수행되며, transport layer와 internet layer는 OS의 커널 모드에서 수행되는 레이어라는 것이다. 우리는 application 레벨에서 코드를 통해 통신을 수립할 수 있게 잘 설정해두면 해당 코드를 수행하면서 커널 영역에서 위 작업들을 수행하는 것이라 이해할 수 있다. (커널이 뭔지 잘 모르는 분들에게 소소한 안내를 하자면, 커널은 개발자가 컨트롤할 수 없는 운영체제의 소스코드 중 일부로, 하드웨어를 제어하는 데에 사용되는 코드들이 주를 이루고 있는 영역이다. 운영체제의 커널 코드에 Transport layer와 Internet Layer의 작업을 수행하는 코드가 적혀있다고 이해하면 충분하다.) [참고](https://brewagebear.github.io/linux-kernel-internal-3/)

## 마무리

![](https://miro.medium.com/v2/resize:fit:1080/1*tLGstBS1gwa2IkoQCIICqA.gif)

처음에 단계별로 이해하기엔 OSI 7 Layer가 더 적절할 것 같아서 이를 기준으로 위에서 설명했지만, 앞으로는 TCP/IP 스택을 기준으로 설명할 것 같다. 따라서 이를 기준으로 대략 마무리를 해보자면,

- 통신 과정에서 송수신하는 데이터는 layer들을 거치며 당장 목적지로 가기 위한 정보를 header에 담아 포장되면서(?) 데이터를 보낸다.
- 각 레이어는 각각의 논리적 통신 과정에 따라 프로세스 간 통신인 HTTP, 노드 간 통신인 TCP/UDP 와 같은 통신 방식(프로토콜)들을 가지고 있다.
- Application layer 작업은 OS의 유저 모드, Transport layer와 Internet Layer는 Kernel 모드에서 이루어진다.