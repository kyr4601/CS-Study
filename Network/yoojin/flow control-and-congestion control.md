## **흐름 제어**

- 송신 측과 수신 측은 모두 데이터를 저장할 수 있는 버퍼를 가지고 있다.
- 수신 측이 자신의 버퍼 안에 있는 데이터를 처리하는 속도보다 **송신 측이 데이터를 전송하는 속도가 더 빠르다면, 당연히 수신 측의 버퍼는 언젠가 꽉 차버릴 것이다. 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 된다.**
- 따라서 송신 측은 수신 측의 데이터 처리 속도를 파악하고 자신이 얼마나 빠르게, 많은 데이터를 전송할 지 결정해야한다. → 이것이 바로 TCP의 흐름 제어
- 정리하자면, 흐름 제어는 **송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법**이다.

### **Stop and Wait**

이름 그대로 **상대방에게 데이터를 보낸 후 잘 받았다는 응답이 올 때까지 기다리는 모든 방식**을 통칭하는 말이다. **매번 전송한 패킷에 대해 확인 응답(ACK)을 받은 후에 다음 패킷을 전송**한다.

![Untitled](../yoojin/img/flow%20control-and-congestion%20control_1.png)

그러나 패킷을 하나씩 보내기 때문에 **비효율적**인 방법이다. 

### **Sliding Window**

- 앞서 살펴봤듯이 Stop and Wait를 사용하여 흐름 제어를 하게되면 비효율적인 부분이 있기 때문에, 오늘날의 TCP는 특별한 경우가 아닌 이상 대부분 슬라이딩 윈도우(Sliding Window) 방식을 사용한다.
- 슬라이딩 윈도우는 **수신 측이 한 번에 처리할 수 있는 데이터를 정해놓고 그때 그때 수신 측의 데이터 처리 상황을 송신 측에 알려줘서 데이터의 흐름을 제어하는 방식**이다. **수신 측에서 설정한 윈도우 크기 만큼,** **송신 측에서 확인 응답(ACK) 없이 패킷을 전송**할 수 있게하여 데이터 흐름을 동적으로 조절한다.
- Stop and Wait과 가장 큰 차이점은 송신 측이 **수신 측이 처리할 수 있는 데이터의 양을 알고 있다**는 점이다.

<br>

**윈도우(Window)**

송신 측과 수신 측은 각각 데이터를 담을 수 있는 버퍼를 가지고 있고, 별도로 **윈도우**라는 일종의 마스킹 도구를 가지고 있다. 이때 송신 측은 이 윈도우에 들어있는 데이터를 수신 측의 응답이 없어도 연속적으로 보낼 수 있다.

![Untitled](../yoojin/img/flow%20control-and-congestion%20control_2.png)

최초의 **윈도우 크기는 호스트들의 3-way handshake를 통해 수신 측 윈도우 크기로 설정**되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다. 윈도우 크기는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다. 이때 송신 측과 수신 측은 자신의 현재 버퍼 크기를 서로에게 알려주게 되고, 송신 측은 수신 측이 보내준 버퍼 크기를 사용하여 자신의 윈도우 크기를 정하게 된다. 

<br>

**동작 방식**

윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답(ACK)이 오면, 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.

즉, **송신 TCP는 ACK을 받기 전까지 윈도우 크기 만큼의 세그먼트를 연속해서 전송**할 수 있다.

<br>

## **혼잡 제어**

- 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면, 초과된 데이터는 라우터가 처리하지 못한다. 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 한다.
- 이와 같은 **네트워크의 혼잡을 피하기 위하여 송신 측에서 보내는 데이터의 전송 속도를 강제로 줄이게 되는데**, 이러한 작업을 혼잡 제어(Congestion Control)이라고 한다.
- 정리하자면, **흐름 제어**는 **송 수신 측 사이의 패킷 수를 제어하는 기능**이라 할 수 있으며, **혼잡 제어**는 **네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로우를 방지하는 기능**이다.

### **AIMD (Additive Increase/Multiplicative Decrease)**

한글로 직역하면 합 증가/곱 감소 방식이다. **AIMD 방식은 처음에 패킷을 하나씩 보내고, 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송한다. 만약 전송에 실패하거나 일정 시간을 넘기면 윈도우의 크기를 반으로 줄인다.**

 다만, 윈도우의 크기를 굉장히 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점이 있다.

![Untitled](../yoojin/img/flow%20control-and-congestion%20control_3.png)

### **Slow Start(느린 시작)**

앞서 얘기했듯이 AIMD 방식은 윈도우 크기를 선형적으로 증가시키기 때문에 제대로 된 속도가 나오기까지 시간이 오래 걸린다.

반면 Slow Start는 윈도우의 크기를 1, 2, 4, 8, ...과 같이 **지수적으로 증가**시키다가 혼잡이 감지되면 **윈도우의 크기를 1로 줄이는 방식이다.**

이 방식은 보낸 데이터의 ACK가 도착할 때마다 윈도우의 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지라도, 시간이 가면 갈수록 윈도우의 크기가 점점 빠르게 증가한다는 장점이 있다.

![Untitled](../yoojin/img/flow%20control-and-congestion%20control_4.png)

### **Fast Retransmit(빠른 재전송)**

패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 **순서대로 도착하지 않는 경우**가 생길 수 있다. 이러한 상황이 발생했을 때 **수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다.** 그리고 이런 **중복 ACK를 3개 받으면 재전송이 이루어진다.** 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있다.

![Untitled](../yoojin/img/flow%20control-and-congestion%20control_5.png)
예시

- 세그먼트 1을 수신하면 수신자는 다음에 세그먼트 **2를 요청하는 확인**을 보낸다. (원래 ACK)

- 세그먼트 3을 수신하면 수신자는 다음에 세그먼트 **2를 요청하는 확인**을 보낸다. (첫 번째 중복 ACK)

- 세그먼트 4를 수신하면 수신자는 다음에 세그먼트 **2를 요청하는 확인**을 보낸다. (두 번째 중복 ACK)

- 세그먼트 5를 수신하면 수신자는 다음에 세그먼트 **2를 요청하는 확인**을 보낸다. (세 번째 중복 ACK)


### **Fast Recovery(빠른 회복)**

빠른 회복은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고, 반으로 줄이고 선형 증가시키는 방법이다. 이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.

![Untitled](../yoojin/img/flow%20control-and-congestion%20control_6.png)