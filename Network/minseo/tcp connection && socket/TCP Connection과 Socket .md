# TCP Connection과 Socket

# OSI 7 layer vs. TCP/IP stack

### OSI 7 layer

- 네트워크 시스템 구성을 위한 범용적이고 개념적인 모델
- ISO/IEC에서 OSI 모델 관리

### TCP/IP stack

**TCP/IP stack은 인터넷이 발명되면서 함께 개발된 프로토콜 스택이다 .**

- IETF에서 인터넷 표준을 관리한다.(RFC)
- TCP, UDP, IP.. 스펙은 RFC에서 정의한다.
- TCP, UDP 스펙은 TCP/IP stack의 transport Layer.에 속한 프로토콜이다.
- IP 스펙은 TCP/IP stack의 Internet Layer에 속한 프로토콜이다.

OSI 7 Layer와 TCP/IP stack은 서로 공존하는 개념이기에

![스크린샷 2024-01-26 오후 4.44.37.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.44.37.png)

**TCP/IP stack은 크게 2 파트로 구분된다. application 과 System으로 나눈다.**

- **최상단의 Application Layer (APPLICATION)**
    - 애플리케이션 레벨에서 구현/관리되는 레이어이다.
    - 네트워크 기능을 사용하는데 목적이다.
- **transport layer, internet layer, link layer (SYSTEM)**
    - 하드웨어/펌웨어, OS레벨에서 구현/관리
    - 네트워크 기능을 지원하는데 목적이다.

Socket(소켓), Port(port), TCP connection에 대해 알아보고자 application 과 System으로 크게 나눈다.

# Port의 개념

만약 하나의 프로세서가 네트워크 통신을 하고 싶다면?

![스크린샷 2024-01-26 오후 4.50.42.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_4.50.42.png)

위와 같이 **데이터를 주고 받을 수 있는 통로가 존재**해야 한다. 

**port**

- process와 연결된 data path or data channel
- port name을 통해 식별
- port(number)의 정의: 16 비트로 이루어진 숫자 (0~65535)

하나의 Application Layer에서 동작하는 여러 종류의 Process는 모두 네트워크 동작이 필요하다.

이떄 각각의 **Process는 Port를 통해 통신**한다.

한 컴퓨터 시스템 안에서 여러개의 포트가 존재할 수 있기 때문에, 이 Port를 어떻게 Unique하게 식별할것인가?

**보통 Port name을 통해 식별**한다. 그런데, **각각의 포트에 대해서 어떻게 지정할지는 각 OS, 시스템마다 방법이 다르다.**

지금은 Process 하나에 port한개를 연결시켰지만, Process 하나에 2개의 Port 이상이 연결될 수도 있다. (설명을 위해 간단하게 Process 1개에 Port 1개로 가정한다.)

# TCP Connection 의 개념

1. **프로세스 간의 안정적이고 논리적(물리적인과 반대)인 통신 통로**  물리적인것이 아닌 **논리적**임.

2. **Connection 을 열고, (3 way handshake), 데이터를 주고받고, connection (4 way handshake) 을 닫는다.**

**TCP에서 데이터를 주고받기 위해서는 connection을 열고, 주고받고, 닫는다**라고 이해하면 된다.

데이터를 주고받기 전에 Connection을 여는 이유는 프로세스 간의 안정적인 통신을 위해서는 몇가지 SET UP이 필요하기에 Connecton을 여는동안 해당 과정이 실행되고, Connection을 닫는 동안 받아온 자원을 반환한다.

이 과정을 **connection-oriented** 라고한다. connection 에 기반으로 동작하는 프로토콜을 의미하며, 이런 과정을 통해 데이터를 주고받는다고 이해하자. 

그럼 인터넷에서 어떻게 port를 유니크하게 식별할까? 

# Port 식별 : port number의 개념

프로세스 간의 통신을 위해서는 상대방 프로세스의 Port를 식별할 수 있어야한다.

**1. port(number)를 정의한다. OS/시스템마다 다를 수 있는데 이것을 number로 정의한다**

16bits 로 이루어진 숫자 ( 0 ~ 65535 ) 이다.

Port라는 개념은 Port 자체로도 쓰이고 숫자로도 쓰이기에 여러가지를 의미한다.

Port number 만으로는 유니크하게 식별할 수 없다. (값의 범위가 0~65535 이기에 부족하다.)

**2. Internet Address(IP Address)로 각 host를 유니크하게 식별할 수 있다.**

각 호스트안에서 포트넘버는 고유하게 지정하고, 각 호스트는 Internet Address로 식별이 가능하니 Internet **address + port number**로 유니크하게 조합한다.

이것이 바로 Socket 이다.

# Socket 개념

I**nternet Address + port number로 인터넷상의 모든 포트를 Unique하게 식별할 수 잇다.**

이러한 개념이 Socket이다.

Socket 이라는 개념은 인터넷 상에 존재하는 **각 port를 유니크하게 식별하기 위한 주소이다.**

**TCP IP Stack이라는 것은, 엄밀히 말하면 주소, namespace를 의미하는 공간이며,** Socket이 곧 **Internet Address + Port라고 할 수 있다.**

**각 Socket은 인터넷 상에서 유니크해야한다. 고유해야한다.**

# TCP Connection과 Socket의 관계

- **각 Connection은 유니크하게 식별되어야한다.** (그러나 port number만으로는 한계가 있다)
- **한 쌍의 Socket은 connection을 유니크하게 식별한다.**
    
    컴퓨터 A의 IP + Port로 Socket A가 생성된다.
    
    컴퓨터 B의 IP + Port로 Socket B가 생성된다.
    
    그리고 한 쌍의 Socket은 인터넷 공간에서 unique하다.
    

< src socket  , dest socket  >

![스크린샷 2024-01-26 오후 5.41.19.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.41.19.png)

커넥션 요청한 쪽이 src, 받는쪽이 dest이다.한쌍의 Socket이 커넥션을 이루고, 한쌍의 Socket으로 커넥션이 유일하다.

Ip Address와 Port Number가 Socket인데 각각을 풀어보면,

< src internet addr, src port, dest internet addr, dest port >

![스크린샷 2024-01-26 오후 5.43.29.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.43.29.png)

여기서 Socket의 관점에서 Connection과의 관계를 확인한다.즉  이 4개의 값을 통해 connection을 유니크하게 식별할 수 있다. 

- **하나의 Socket은 동시에 여러 connection 들에서 사용될 수 있다.**

지금은 예를들기 위해 컴퓨터 A와 컴퓨터 B를 기준으로만 진행했지만, 만약 컴퓨터 B에서 제공하는 여러 서비스를 다른 컴퓨터들에서 이용할 수 있어야하기에, 인터넷의 다른 프로세스들도 컴퓨터 B Process에 연결이 되어야하기에 이떄  Socket B는 다른 COnnection들에서도 사용될 수 있기에 그렇다. 즉, 하나의 Socket은 여러 Connection 들에서 사용될 수 있다.

# UDP

같은 transport layer에 TCP와 UDP 가 존재한다.

UDP(User Datagram Protocol)는 connectionless 프로토콜이다.

**TCP는 연결 기반의 프로토콜인데, UDP는 연결을 맺지않고 바로 데이터를 주고받는다.**

즉 UDP는 unreliable한 프로토콜이다. (internet protocol 위에서 사용되는 거의 그대로 사용하는 프로토콜이기 때문)

단지, 한 호스트 내에 존재하는 다양한 프로세스들이 UDP 통신을 할 수 있도록 하는 기능을 제공하고, 간단한 에러체크만 제공한다.

# TCP/IP stack에서 Socket의 개념

Socket은 Port를 식별하기 위한 주소인것인데,

<protocol, ip address, port number>로 Socket을 유니크하게 식별한다.

원래 TCP에서만 사용된다면 Ip address와 port number로만 식별되었지만,

TCP와 UDP를 동시에 사용하면서 protocol도 추가되어 socket을 식별한다.

### 표준에서 정의한 개념을 바탕으로 예제이다.

한개의 컴퓨터와 프로세스 A, 프로세스 B가 존재한다.

만약 TCP 기반으로 통신하고 싶다면, <protocol, ip address, port number>

![스크린샷 2024-01-26 오후 5.56.53.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_5.56.53.png)

그러나 위 경우는 소캣이 유니크 하지 않기 때문에 통신이 불가능하다. ( protocol, ip address, port number 중 하나라도 다르면 된다. ⇒ 경우의 수 : 6)

![스크린샷 2024-01-26 오후 6.04.02.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.04.02.png)

이제 인터넷상의 다른 Host C 가 프로세스 A의 서비스를 이용하고자한다.

**각각의 TCP 커넥션은 Socket의 쌍으로 유니크하게 표현된다.**

![스크린샷 2024-01-26 오후 6.10.43.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.10.43.png)

- Socket A — Socket B

Socket A < TCP, 77.77.77.77, 3001> — Socket B<TCP, 50.50.50.50., 8081>

즉, Connection은 **<77.77.77.77, 3001, 50.50.50.50, 8282>** 로 커넥션이 연결된다.

- Socket C - Socket B

Socket C <TCP, 33.33.33.33, 3001> — Socket B<TCP, 50.50.50.50., 8081>

**< 33.33.33.33, 3001,  50.50.50.50, 8282>** 로 커넥션이 연결된다.

**그러나, Connection 은 반드시 Unique해야한다.** (위의 경우 IP주소가 다르므로 unique하다 )

![스크린샷 2024-01-26 오후 6.23.14.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.23.14.png)

만약 같은 Host C에서 같은 IP이지만, Port가 다르다면 또 Unique한 Connection을 생성할 수 잇다.

Connection은 <77.77.77.77, 3000, 50.50.50.50, 8282> 로 커넥션이 연결된다.

![스크린샷 2024-01-26 오후 6.23.56.png](TCP%20Connection%E1%84%80%E1%85%AA%20Socket%208685a07deee740bdab18c1ef955851d0/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-01-26_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.23.56.png)

**하나의 socket이 여러 connection에서 사용가능하다. 이렇게 프로토콜 스펙에서 정의한다.**

### 주의사항

실제로 네트워크 프로그래밍을 할때는 소켓의 개념과 의미가 미묘하게 다르다.

특히 소켓을 식별하는 방법에서 큰 차이가 있다.

# CS 질문

### **1) TCP 특징**

- 연결형 서비스로 가상 회선 방식을 제공한다.
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어.
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식

### **2) TCP 서버 특징**

- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다형 서비스로 가상 회선 방식을 제공한다.
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)

![https://blog.kakaocdn.net/dn/bVLOcT/btrAccetXRL/HJqDuGvSUYwr5pt0lKdBF0/img.png](https://blog.kakaocdn.net/dn/bVLOcT/btrAccetXRL/HJqDuGvSUYwr5pt0lKdBF0/img.png)

### **3) UDP 특징**

- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다

### **4) UDP 서버 특징**

- UDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

### **5) UDP는 항상 신뢰성을 보장하지 않나요?**

- UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. HTTP/3의 경우, UDP 기반의 QUIC이라는 프로토콜을 사용합니다. UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.

| 프로토콜 종류 | TCP | UDP |
| --- | --- | --- |
| 연결 방식 | 연결형 서비스 | 비연결형 서비스 |
| 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식 |
| 전송 순서 | 전송 순서 보장 | 전송 순서가 바뀔 수 있음 |
| 수신 여부 확인 | 수신 여부를 확인함 | 수신 여부를 확인하지 않음 |
| 통신 방식 | 1:1 통신 | 1:1 OR 1:N OR N:N 통신 |
| 신뢰성 | 높다. | 낮다. |
| 속도 | 느리다. | 빠르다. |

---