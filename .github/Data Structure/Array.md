## **Array (배열)**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/1eec8832-fa93-4c7d-9472-9f11a4a4a946/2df0e263-d8a8-45aa-b06a-8bca025618e7/Untitled.png)

### 특징

배열은 연속된 메모리 공간에 순차적으로 저장된 데이터 모음

배열을 구성하는 각각의 값을 `요소(element)`라고 하며, 

배열에서의 위치를 가리키는 숫자는 `인덱스(index)`라고 한다.

각 요소는 인덱스를 통해 접근 가능하다.

### 장점

1. 빠른 접근 : 배열은 인덱스를 사용하여 요소에 빠르게 접근할 수 있다.
2. 메모리 공간의 효율성 : 배열은 연속된 메모리 공간에 요소를 저장하므로, 메모리 공간을 효율적으로 사용할 수 있다. 
3. 다차원 배열 : 배열은 다차원으로 선언할 수 있다. 

### 단점

1. 크기 제한 : 배열은 생성할 때 크기를 정하고 이 크기를 변경할 수 없다. 따라서 미리 최대 크기를 예상하여 배열을 생성해야 하며, 크기를 동적으로 조정할 수 없는 제약이 있다.
2. 삽입과 삭제의 어려움 : 배열은 요소를 삽입하거나 삭제하는 작업에 비용이 크다. 배열의 중간에 요소를 삽입하거나 삭제할 경우 해당 위치 이후의 요소들을 모두 이동시켜야 하기 때문이다. 

### 시간 복잡도

**1. 접근**  O(1)

접근은 배열 내에서 n번째 인덱스에 해당하는 값을 찾아내는 연산이다.

배열의 접근은 O(1)의 시간복잡도를 갖는다. 따라서 찾고자 하는 값이 몇 번째 인덱스에 있는지 알고 있다면 굉장히 빠른 검색 속도를 갖는다. 

**2. 탐색** O(n)

!https://blog.kakaocdn.net/dn/ebR7Gv/btqUWtaBdb1/PsZJhqmDd2BUy8b9OpJfw1/img.jpg

배열의 검색은 순차검색이다. 

인덱스를 알지 못할 때 원하는 값을 찾기 위해 배열을 하나하나 확인해야한다.

A[3]의 값을 찾기 위해 A[0], A[1]... 을 순서대로 검색한다. 따라서 최대 O(n)의 시간 복잡도를 가진다.

**3. 삽입, 삭제** O(1) ~ O(n) 

!https://blog.kakaocdn.net/dn/ctbBif/btqU0xXor35/tv2mfnmBKKakoWTN1FokYk/img.jpg

A[6]에 5라는 값을 넣고, 혹은 빼고 싶을 때 해당 인덱스를 정확하게 알고 있다면 접근의 개념으로 O(1)의 시간복잡도를 가지지만 해당 인덱스를 찾아야한다면 검색의 시간복잡도인 O(n)에 해당한다.

<aside>
💡 장단점과 시간복잡도를 고려했을 때 주로 다음과 같은 상황에서 배열 사용

- 다차원 데이터를 다룰 때
- 순차적인 데이터를 저장하며 값보다는 순서가 중요할 때
- 어떤 특정 요소를 빠르게 읽어야 할 때
- 데이터 사이즈가 자주 바뀌지 않으며 요소가 자주 추가되거나 삭제되지 않을 때
</aside>