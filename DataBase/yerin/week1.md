# DB 1주차
https://hyper-hotel-11e.notion.site/DB-1-75604ccc24b34c899a271dedcfff8425?pvs=4

# 📌데이터 베이스 기본

## 🔸DB

데이터의 집합

## 🔸DBMS

**데이터베이스를 관리하고 운영하는 소프트웨어를 DBMS(Database Management System)**라고 한다. 다양한 데이터가 저장되어 있는 데이터베이스는 여러 명의 사용자나 응용 프로그램과 공유하고 동시에 접근이 가능해야 한다.

## 🔸기본 용어

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled.png)

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%201.png)

### 릴레이션 = 테이블 = (스키마 + 인스턴스)

### 스키마

- 스키마는 관계형 데이터베이스에서 기본 구조를 정의하는 것
- 스키마는 테이블의 첫 행인 헤더를 나타내며, 속성, 자료타입 등의 정보를 담고 있다.

### 인스턴스

- 인스턴스는 테이블에서 실제로 저장된 데이터

### Tuple(튜플) = Row(행)

- 튜플은 릴레이션에서 행(가로)의 개수
- 위 그림에서 튜플의 개수는 3입니다

### Attribute(속성) = Column(열)

- 속성은 릴레이션에서 열(세로)의 개수
- 위 그림 속성의 개수는 3입니다

### 도메인

- 도메인은 속성이 가질 수 있는 값의 집합
- 예를 들면 성별이라는 속성에는 male, female 2가지 도메인이 존재

# 📌키

### Key란?

릴레이션에서는 수많은 튜플들이 있다. 릴레이션에 많은 튜플이 존재하며 각 튜플들에는 중복되는 값이 발생할 수 있다.

예를 들어 이름, 나이, 사는곳 등이 중복될 수 있는데, 이때 각각의 튜플을 구분하기 위한 기준이 되는 속성이 필요하다. 이것을  "키"라고 하며 속성 또는 속성들의 집합으로 표현할 수 있다. 

### **최소성 & 유일성**

**유일성 : 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질**

여러개의 튜플이 존재할 때 각각의 튜플을 서로 구분할 수 있어야함. 한마디로 각각의 튜플은 유일해야 함. 예를 들어 (주민번호, 나이, 사는곳, 혈액형)이라는 속성이 있을 때 나이, 사는곳, 혈액형은 중복 가능한 속성임. 하지만 주민번호는 모두 다르기 때문에 절대 중복될 수 없다. 이렇게 각각의 튜플을 구분할 수 있는 성질을 유일성이라고 한다.

**최소성 : 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질**

 키를 구성하는 속성들이 진짜 각 튜플을 구분하는데 꼭 필요한 속성들로만 구성되어 있나?를 의미한다. 굳이 없어도 될 속성들을 넣지 말자. 예를 들어 다음과 같은 키(주민번호, 이름, 나이)가 있다면, 물론 현재의 키는 각 튜플을 구분할 수 있다. 하지만 이름, 나이를 빼고 주민번호만으로 각 튜플을 유일하게 식별할 수 있다. 이때 이름, 나이를 빼면 해당 키는 최소성을 만족한다.

- 슈퍼 키(Super Key) : 유일성을 만족하는 키
- 복합 키(Composite Key) : 2개 이상의 속성(attribute)를 사용한 키
- 후보 키(Candidate key) : 유일성과 최소성을 만족하는 키. 기본키가 될 수 있는 후보이기 때문에 후보키라고 불린다.
- 기본 키(Primary key) : 후보 키에서 선택된 키. NULL값이 들어갈 수 없으며, 기본키로 선택된 속성(Attribute)은 동일한 값이 들어갈 수가 없다.
    1. 널 값을 가질 수 있는 속성이 포함된 후보키는 기본키로 부적절 합니다.
    2. 값이 자주 변경될 수 있는 속성이 포함된 후보키는 기본키로 부적절 합니다.
    3. 단순한 후보키를 기본키로 선택합니다.
- 대체 키(Surrogate key) : 후보 키 중에 기본 키로 선택되지 않은 키.
- 외래 키(Foreign Key) : 어떤 테이블 간의 기본 키(Primary key)를 참조하는 속성이다. 테이블들 간의 관계를 나타내기 위해서 사용된다.

### 데이터베이스 무결성

- ***개체 무결성 Entity Integrity***
    - 첫번째 조건 : 기본키를 구성하는 속성은 `null`값을 가질 수 없다
    - 두번째 조건 : 기본키를 구성하는 속성은 다른 레코드와 `중복`될 수 없다.
- ***참조 무결성 Referential Integrity***
    - 외래키를 구성하는 속성은 참조 릴레이션(테이블)의 `기본키` 값과 동일해야한다.
        
        ex) A릴레이션의 기본키(학번)에 3이 없는데 B릴레이션에서 A릴레이션을 참조하고자 할 때 외래키 값에 3을 입력하는 경우 참조 무결성 위반
        
        (FK는 참조하는 릴레이션의 PK값 혹은 NULL을 가져야함)
        
- ***도메인 무결성 Domain Integrity***
    - 속성값은 속성이 정의된 도메인의 범위를 벗어날 수 없다.
        
        ex) 예를 들어 <강의> 릴레이션의 '과목명' 속성에는 영어, 수학, 국어 세 가지만 입력되도록 유효값이 지정된 경우 반드시 해당 값만 입력해야 한다.
        
    

# 📌ERD & 정규화

## 🔸ERD

ERD(Entity Relationship Diagram)는 요구 분석 사항에서 얻은 엔티티와 속성들의 관계를 그림으로 나타낸 개체-관계 모델이다

테이블과의 관계를 설명하는 다이어그램이며, 이를 통해 프로젝트에서 사용하는 데이터베이스의 구조를 한눈에 파악할 수 있다

### ERD 관계

entity의 관계를 나타낼때 선을 이어 관계를 나타내는데, 

실선과 점선으로 나뉘어진다.

- 실선은 식별자 관계
    
    부모 테이블의 기본키를 자식 테이블이 가지고 있으며 이를 기본키로 사용하는 경우
    
- 점선은 비식별자 관계
    
     부모 테이블의 기본키를 자식테이블이 가지고 있지만 이를 기본키로 사용하지 않을 때 사용
    

### ERD Carinality & 필수참여 조건

Cardinality는 한 개체에서 발생할 수 있는 발생 횟수를 정의하며, 다른 개체에서 발생할 수 있는 발생 횟수와 연관된다

- One to one → 1:1
- One to many → 1:M
- Many to One → M:1
- Many to many → M:N

필수참여 조건이란 엔티티와 엔티티의 관계를 나타낼 때 한 엔티티가 다른 엔티티를 필수적으로 가지고 있는지 안그래도 되는지를 나타낼 때 사용한다.

- 연결선의 끝부분이 O ⇒ 선택참여로 있어도 되고 없어도 된다.
- 연결선의 끝부분이  | ⇒필수참여로 반드시 있어야 한다.
- 연결선의 끝부분이 세갈래 ⇒ 1개 이상을 의미한다.

### 1:1

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%202.png)

한 명의 학생은 하나의 신체 정보를 갖는다.

### 1:M

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%203.png)

한 명의 학생은 여러 개의 취미를 가질 수도 있다.

### M:N

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%204.png)

TV는 삼성, LG 등 여러 제조업체를 가질 수 있다.

한 제조업체는 TV 뿐만 아니라 세탁기, 핸드폰 등을 만들 수 있다.

<aside>
💡 그런데 두 엔티티가 다 대 다 관계에 있는 경우, 두 개의 엔티티만으로는 서로를 표현하는데 부족하다. 데이터 모델링에서는 M:N 관계를 완성되지 않은 모델로 간주하여, 두 엔티티의 관계를 1:N, N:1 로 조정하는 작업이 필요하다. 따라서 두 엔티티의 관련성을 표현하기 위해서는 중간에 또 다른 엔티티를 필요로 한다. 이 중간 엔티티(업체별 제품)가 두 엔티티의 공유 속성 역할을 하게 된다.

</aside>

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%205.png)

나누기 전 엔티티의 각 PK를 FK로 갖는다.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%206.png)

### ERD 관계의 참여도

관계선 각 측의 끝자락에 기호를 표시한다.

'|' 표시가 있는 곳은 반드시 있어야 하는 개체. (필수)

'O' 표시가 있다면 없어도 되는 개체. (선택)

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%207.png)

취미를 가진 학생이 있을 수도 있고, 취미가 없는 학생이 있을 수도 있다.

어떤 학생이 취미를 갖는데 그 학생이 존재하지 않는 건 말이 안 된다.

---

## 🔸정규화

정규화(Normalization)의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는다는 것이다. 중복된 데이터를 허용하지 않음으로써 무결성(Integrity)를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%208.png)

### 제 1 정규형

- 모든 속성은 원자 값을 가져야 함
- 다중 값을 가질 수 있는 속성은 분리되어야 함

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%209.png)

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2010.png)

### 제 2 정규형

- 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것 (완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.)

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2011.png)

기본키 : 학생번호, 강좌이름 (복합키)

학생번호, 강좌이름 ⇒ 성적 결정

강좌이름(기본키의 부분집합) ⇒ 강의실 결정

즉, 기본키의 부분키인 강좌이름이 결정자이기 때문에 강의실을 분해하여 별도의 테이블로 관리함으로써 제2 정규형을 만족시킬 수 있다.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2012.png)

### 제 3 정규형

- 제 2 정규형을 만족하고 일반 속성들간에도 종속관계가 존재하지 않아야 함
- 제2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분해하는 것이다. (이행적 종속이라는 것은 A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미한다.)

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2013.png)

기존의 테이블에서 학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다. 그렇기 때문에 이를 (학생 번호, 강좌 이름) 테이블과 (강좌 이름, 수강료) 테이블로 분해해야 한다.이행적 종속을 제거하는 이유는 비교적 간단하다. 예를 들어 501번 학생이 수강하는 강좌가 스포츠경영학으로 변경되었다고 하자. 이행적 종속이 존재한다면 501번의 학생은 스포츠경영학이라는 수업을 20000원이라는 수강료로 듣게 된다. 물론 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것이다.즉, 학생 번호를 통해 강좌 이름을 참조하고, 강좌 이름으로 수강료를 참조하도록 테이블을 분해해야 하며 그 결과는 다음의 그림과 같다.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2014.png)

### BCNF 정규화

- 제 3 정규형을 좀 더 강화한 버전으로, 3 정규형을 만족하면서 모든 결정자가 후보키 집합에 속해야한다. 즉, 후보키 집합에 없는 칼럼이 결정자가 되어서는 안 된다.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2015.png)

학생번호, 과목 → 지도교수 (O)

과목 → 지도교수 (X)

지도교수 → 과목 (O)  ⇒ 후보키 집합이 아닌 지도교수가 결정자가 됨.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2016.png)

보통 정규화는 BCNF 까지만 하는 경우가 많다고 한다.

그 이상 정규화를 하면 정규화의 단점이 나타날 수도 있어서.

# 📌JOIN

## JOIN이란?

PK-FK로 연관된 두 테이블을 묶어 하나의 테이블로 만드는 방법.

서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로, 각 테이블에 저장된 데이터를 효과적으로 검색이 가능하다.

## JOIN 종류

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2017.png)

### inner join

**두 테이블에서 ‘공통된 값’을 가지고 있는 행들만을 반환**

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2018.png)

```jsx
SELECT *
FROM   테이블1
INNER JOIN 테이블2
ON 테이블1.열 = 테이블2.열;
```

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2019.png)

### outer join

**두 테이블에서 ‘공통된 값을 가지지 않는 행들’도 반환**

Left outer Join, Right outer Join, Full outer Join

**Left outer Join**

’왼쪽 테이블의 모든 행’과 ‘오른쪽 테이블에서 왼쪽 테이블과 공통된 값’을 가지고 있는 행들을 반환

만약 오른쪽 테이블에서 공통된 값을 가지고 있는 행이 없다면 NULL 값을 반환

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2020.png)

```jsx
SELECT *
FROM 테이블1
LEFT JOIN 테이블2
ON 테이블1.열 = 테이블2.열;
```

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2021.png)

**Right outer Join**

Left Join과 반대로 ‘오른쪽 테이블의 모든 행’과 ‘왼쪽 테이블에서 오른쪽 테이블과 공통된 값’을 가지고 있는 행들을 반환한다. 만약 왼쪽 테이블에서 공통된 값을 가지고 있는 행이 없다면 NULL 값을 반환

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2022.png)

```jsx
SELECT *
FROM 테이블1
RIGHT JOIN 테이블2
ON 테이블1.열 = 테이블2.열;
```

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2023.png)

**Full outer Join**

두 테이블에서 ‘모든 값’을 반환

만약 공통된 값을 가지고 있지 않는 행이 있다면 NULL 값을 반환합니다.

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2024.png)

```jsx
SELECT *
FROM 테이블1
FULL OUTER JOIN 테이블2
ON 테이블1.열 = 테이블2.열;
```

![Untitled](DB%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2075604ccc24b34c899a271dedcfff8425/Untitled%2025.png)

# 📌SQL Injection

## SQL Injection이란?

웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 데이터베이스의 중요한 정보를 가져오는 해킹 기법. 클라이언트가 입력한 데이터를 제대로 필터링 하지 못하는 경우 발생하며, 공격 난이도가 쉬운데 비해 피해 규모가 큼.

## 공격 종류 및 방법

- Error based SQL Injection
    
    논리적 에러를 이용 / 가장 대중적인 공격 기법
    
    ex) 
    
    로그인
    
    정상접근 -> Select * from cliend where name='anjinma' and password='12345'
    
    SQL Injection -> Select * from client where name='anjinma' and password=' or '1'='1'
    
    ' or '1'='1'를 넣어서 1과 1이 같아서 항상 참이므로 로그인에 성공하게 된다.
    
- Union based SQL Injection
    
    Union 명령어를 이용
    
    Union Injection을 성공하기 위해서는 Union 하는 두 테이블의 컬럼 수가 같아야 하고, 데이터 형이 같아야 함.
    
    ex)
    
    어떤 게시글 테이블에서 제목과 내용을 출력하는 쿼리문이 있을때 id와 password를 요청하는 쿼리를 union 키워드와 함께 넣어주고 인젝션이 성공하게 되면 사용자의 개인정보가 게시글과 함께 화면에 보이게 된다
    
- Blind SQL Injection - Boolean based SQL Injection
    
    데이터베이스로부터 특정한 값이나 데이터를 전달받지 않고, 단순히 참과 거짓의 정보만 알 수 있을 때 사용. 로그인 폼에 SQL Injection이 가능하다고 가정 했을 때, 서버가 응답하는 로그인 성공과 로그인 실패 메시지를 이용하여, DB의 테이블 정보 등을 추출해 낼 수 있다.
    
- Blind SQL Injection - Time based SQL Injection
    
    Time Based SQL Injection 도 마찬가지로 서버로부터 특정한 응답 대신에 참 혹은 거짓의 응답을 통해서 데이터베이스의 정보를 유추하는 기법
    
- Stored Procedure SQL Injection
    
    저장 프로시저는 일련의 쿼리들을 모아 하나의 함수처럼 사용하기 위한 것. 공격에 사용되는 대표적인 저장 프로시저는 윈도우 명령어를 사용할 수 있게 되어 있다. 공격난이도가 높으나 공격자가 시스템 권한을 획득해서 공격에 성공한다면, 서버에 직접적인 피해를 입힐 수 있는 공격
    
- Mass SQL Injection
    
    보통 데이터베이스 값을 변조하여 데이터베이스에 악성스크립트를 삽입하고, 사용자들이 변조된 사이트에 접속 시 좀비PC로 감염되게 합니다. 이렇게 감염된 좀비 PC들은 DDoS 공격에 사용됩니다.
    

## 대응방법

- 웹방화벽 사용
- 에러 메시지 노출 금지
    
    에러 발생 시 따로 처리를 해주지 않았다면, 에러가 발생한 쿼리문과 함께 에러에 관한 내용을 반환해주는데 여기서 테이블명 및 컬럼명 그리고 쿼리문이 노출이 될 수 있기 때문에, 데이터 베이스에 대한 오류발생 시 사용자에게 보여줄 수 있는 페이지를 제작 혹은 메시지박스를 띄우도록 해야한다.
    
- Prepared Statement 구문사용
    
    Prepared Statement 구문을 사용하게 되면, 사용자의 입력 값이 데이터베이스의 파라미터로 들어가기 전에DBMS가 미리 컴파일 하여 실행하지 않고 대기합니다. 그 후 사용자의 입력 값을 문자열로 인식하게 하여 공격쿼리가 들어간다고 하더라도, 사용자의 입력은 이미 의미 없는 단순 문자열 이기 때문에 전체 쿼리문도 공격자의 의도대로 작동하지 않습니다.
    

 inner join과 outer join의 차이를 설명해주시고 실제 프로젝트에서 어떤 상황에서 사용을 해봤는지 경험에 빗대어 설명해주세요.

inner join 은 서로 연관된 내용만 검색하는 조인 방법입니다. A와 B에 대해 수행하는 것은, A와 B의 교집합을 말합니다. 벤다이어그램으로 그렸을 때 교차되는 부분입니다. outer join 은 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법입니다. 

A와 B에 대해 수행하는 것은, A와 B의 합집합을 말합니다. 벤다이어그램으로 그렸을 때 합집합 부분입니다. outer join에는 LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있습니다.