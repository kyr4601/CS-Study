# DB 2주차

# 📌RDBMS & NoSQL

## RDBMS

- 관계형 데이터베이스(RDB)는 테이블, 행, 열의 정보를 구조화하는 방식이다. RDB에는 테이블을 조인하여 정보 간 관계 또는 링크를 설정할 수 있는 기능이 있어, 여러 데이터 포인트 간의 관계를 쉽게 이해하고 정보를 얻을 수 있다.
- RDBMS 종류에는 `MySQL`, `PostgreSQL`, `Oracle`, `Microsoft SQL Server`, `MariaDB` 등이 있다.

### 장점

- 직관적인 데이터 표현 방법을 제공 (명확한 스키마 정의)
- 관련 데이터 포인트에 쉽게 액세스 가능
- 유연성
    
    전체 데이터베이스 구조를 변경하거나 기존 애플리케이션에 영향을 주지 않고 필요할 때마다 간편하게 테이블, 관계를 추가 또는 삭제하고 데이터를 변경할 수 있습니다.
    
- ACID 규정 준수
    
    관계형 데이터베이스는 ACID(원자성, 일관성, 격리, 내구성) 성능을 지원하므로 오류, 실패, 기타 잠재적 오작동에 관계없이 데이터 유효성을 검사할 수 있습니다.
    
- 사용 편의성
    
    기술자가 아닌 사용자도 데이터베이스와 상호작용하는 방법을 배울 수 있는 SQL을 사용하여 복잡한 쿼리를 쉽게 실행할 수 있습니다.
    
- 공동작업
    
    여러 사용자가 동시에 데이터를 운영하고 액세스할 수 있습니다. 기본 제공되는 잠금 기능으로 업데이트 도중 데이터에 동시 액세스할 수 없습니다.
    
- 내장된 보안 기능
    
    역할 기반 보안을 통해 데이터 액세스가 특정 사용자로 제한됩니다.
    
- 데이터베이스 정규화
    
    관계형 데이터베이스는 데이터 중복성을 줄이고 데이터 무결성을 개선하는 정규화라는 설계 기법을 사용합니다.
    

### **단점**

- 유연성이 떨어져 데이터 스키마를 사전에 계획해야 하므로 추후 수정이 어렵다.
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있다.
- 대체로 수직적 확장만 가능하다.

## NoSQL

NoSQL은 비관계형 데이터베이스로 SQL, 즉, 관계형 데이터베이스를 제외한 나머지 유형

비관계형 데이터베이스를 칭할 때 NoSQL(또는 NoSQL 데이터베이스)라고 부른다.

- NoSQL 데이터베이스는 테이블 형식이 아니다.
- 데이터 유형에 따라 다양한 유형을 갖추고 있으며, 주요 유형으로는 문서, 키 값, 와이드 컬럼, 그래프 등이 있다.
- NoSQL이라고 해서 꼭 스키마가 없는 것은 아님. 유연한 스키마를 제공하며, 대량의 데이터와 높은 사용자 부하에서도 손쉽게 확장할 수 있다는 점이 큰 장점이다. 또한 데이터를 읽어올 때 스키마에 따라 데이터를 읽어 온다.

### **NoSQL의 장점**

- 스키마가 없기 때문에 유연하고 언제든지 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장되기 때문에 데이터를 읽어오는 속도가 빨라진다.
- 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기와 쓰기 요청 처리가 가능하다.

### **NoSQL의 단점**

- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있다.
- 데이터 중복을 계속 업데이트해야 한다.
- 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정이 필요한 경우 모든 컬렉션에서 수행해야 한다.

### NoSQL 저장 기술 4가지

1. key - value
    
    Key를 고유한 식별자로 사용하는 Key - Value 쌍의 집합으로 데이터를 저장.
    
    - 구현이 매우 간단합니다.
    - Key를 가지고 데이터를 불러오기 때문에 대체로 검색이 빠릅니다. (대신 value로는 검색이 힘듭니다.)
    - 대부분의 데이터형이 저장이 가능합니다.
    - 확장성이 좋습니다.

1. Document
    
    JSON, BSON, XML 등의 형식으로 저장하는 방식
    
    - 생산성이 좋습니다.
    - 유연성이 뛰어납니다. (스키마가 존재하지 않으며 각 문서마다 같은 필드를 가지고 있을 필요가 없습니다.)
    - 필드에 따라 쿼리가 가능합니다.
    - 확장성이 좋습니다.

1. Graph
    
    그래프의 형태로 저장하는 데이터베이스
    
    - Graph 시각화도 같이 있는 경우가 많습니다.
    - 각 데이터들 간의 관계를 찾는데 특화되어 있습니다.

1. wide column
    
    ![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled.png)
    
    행마다 키와 해당 값을 저장할 때마다 각각 다른값의 다른 수의 스키마를 가질 수 있는 형식
    
    사용자의 이름(key)에 해당하는 값에 스키마들이 각각 다름을 볼 수 있다.
    
    - 대량의 데이터에서 상대적으로 쿼리 속도가 빠릅니다.
    - 확장성이 좋습니다.

### RDBMS vs NoSQL

**데이터 저장(Storage)**

RDBMS ⇒ SQL 언어를 통해 테이블에 저장. 미리 작성된 스키마를 기반으로 정해진 형식에 맞게 데이터를 저장해야만 한다.

NoSQL ⇒ key-value, document, wide-column, graph 등의 방식으로 데이터를 저장

**스키마(Schema)**

RDBMS ⇒ 고정된 스키마 필요. 처리하려는 데이터 속성별로 열(column)에 대한 정보를 미리 정해야만 데이터 처리가 가능한 것입니다. 스키마는 나중에 변경할 수 있지만, 데이터베이스 전체를 수정하거나 오프라인으로 전환해야 할 수도 있기 때문에 처음에 신중하게 스키마를 정의해야 합니다.

NoSQL ⇒ 관계형 데이터베이스에 비해 유연하게 스키마의 형태 관리 가능. 행을 추가할 때 즉시 새로운 열을 추가할 수 있고, 개별 속성에 대해서 모든 열에 대한 데이터를 반드시 입력하지 않아도 됩니다.

**쿼리(Query)**

RDBMS ⇒ 테이블의 형식과 테이블 간의 관계에 맞춰 데이터를 요청해야 합니다. 요청하는 방식이 정해져 있기 때문에 SQL 언어와 같이 구조화된 쿼리 언어를 사용하는 것입니다.

NoSQL ⇒ 데이터 그룹 자체를 조회하는 것에 초점을 두고 있기 때문에 구조화되지 않은 쿼리 언어로도 데이터를 요청할 수 있습니다.

**확장성(Scalability)**

RDBMS ⇒ 수직적으로 확장하며 높은 메모리와 CPU를 사용합니다. 데이터베이스가 구축된 하드웨어의 성능을 많이 이용하므로 비용이 비싼 편이며, 여러 개의 서버에 걸쳐서 데이터베이스의 관계를 정의할 수 있지만 매우 복잡하고 시간이 오래 걸리는 것이 단점입니다.

NoSQL ⇒ 반대로 수평적으로 확장합니다. NoSQL 데이터베이스를 위한 서버를 추가로 구축하게 되면 많은 트래픽을 편리하게 처리할 수 있다는 장점이 있습니다. SQL보다 저렴한 범용 하드웨어나 클라우드 기반의 인스턴스에 NoSQL 데이터베이스를 호스팅 할 수 있어 상대적으로 비용이 저렴한 것이 장점입니다.

# 📌저장 프로시저

일련의 쿼리를 마치 하나의 함수처럼 실행하기 위한 쿼리문들의 집합

특정 로직의 쿼리를 함수로 만들어 놓은 것

### 일반 쿼리문 작동방식

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_01.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_01.png)

1. **`구문 분석`** : 구문 자체에 오류가 없는지 분석, 오타가 있으면 이 단계에서 에러 메시지 출력
2. **`개체 이름 확인`** : 쿼리문에 속한 테이블(이외에도 속성 등)이 현재 DB에 있는지 확인
3. **`사용권한 확인`** : DB에 접근하는 사용자가 권한이 있는지 확인
4. **`최적화`** : 해당 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 결정, 인덱스 사용 여부에 따라 경로가 결정됨. 
5. **`컴파일 및 실행 계획 등록`** : 해당 실행 계획 결과를 메모리(캐시)에 등록
6. **`실행` :** 컴파일된 결과 실행

### 저장 프로시저 작동방식

**1. 저장 프로시저 정의** 

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_02.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_02.png)

**`구문분석`** : 구문의 오류 파악

**`지연된 이름 확인`** : 저장 프로시저를 정하는 시점에서 해당 개체(ex. 테이블)가 존재하지 않아도 상관없다. 프로시저 실행 당시에 테이블 존재 여부 확인함(개체이름 확인).

(지연된 이름 확인의 경우, 테이블이 존재한다면 확인하기 때문에 테이블의 열,이름이 틀리면 오류발생)

**`생성권한 확인`** : 현재 사용자가 저장 프로시저를 생성할 권한이 있는지 확인

**`시스템 테이블 등록`** : 저장 프로시저의 이름 및 코드가 시스템 테이블에 등록.

**2. 처음 저장 프로시저 실행**

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_03.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_03.png)

구문 분석 단계를 제외하고 일반 쿼리문과 동일

지연된 이름 확인에서 미루어 두었던 해당 개체 존재 유무를 개체 이름 확인을 통해 수행

**3. 이후 저장 프로시저 실행**

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_04.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_04.png)

이후에 두번째 실행 부터는 메모리(캐시)에 있는 것을 그대로 가져와 재사용하게 되어 수행시간을 많이 단축함.

## 저장 프로시저 장점

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_05.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_sp_05.png)

1. **SQL Server의 성능 향상**
    - 여러개의 쿼리를 한번에 실행할 수 있다.
    - 캐시에 있는 것을 가져와 사용하므로 속도가 빨라진다.
    - 쿼리를 쓸 때마다 옵티마이저가 구문을 분석하고 실행 가능한 코드로 바꾸려면 많은 비용이 드는데, 이 비용을 없앨 수 있음
2. **유지보수 및 재활용**
    - 응용프로그램에서 직접 SQL문을 호출하지 않고 SP를 호줄하도록 설정하여 사용하는 경우가 많다. SP 파일만 수정하면 되기 때문에 유지보수에 유리하다.
3. **보안 강화**
    - 사용자 별로 테이블에 권한을 주지 않고, SP에만 접근 권한을 주는 방식
4. **네트워크 부하 감소**
    - 클라이언트에서 서버로 쿼리의 모든 텍스트가 전송될 경우 네트워크에는 큰 부하가 발생
    - 저장 프로시저를 사용하면 저장 프로시저의 이름, 매개변수 등 몇 글자만 전송하면 되기 때문에 부하를 크게 줄일 수 있다.

## 저장 프로시저 단점

1. **DB 확장 어려움**
    - 서버의 수를 늘려야할 때, DB의 수를 늘리는 것이 더 어렵다.
    - DB 교체는 거의 불가능하다.
2. **데이터 분석의 어려움**
    - 개발된 프로시저가 여러 곳에서 사용 될 경우 수정했을 때 영향의 분석이 어렵다.
    - 배포, 버전 관리 등에 대한 이력 관리가 힘들다.
3. **낮은 처리 성능**
    - 문자, 숫자열 연산에 SP를 사용하면 오히려 c, java보다 느린 성능을 보일 수 있다.
    

# 📌Index

> 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
> 

즉, index는 데이터의 주소값을 저장하는 별도의 특별한 자료 구조이다. 

index를 활용해서 빠르게 원하는 데이터를 찾을 수 있다.

## Index 사용 이유

⇒ 조건(where, on..)을 만족하는 튜플을 빠르게 조회하기 위해서

⇒ 빠르게 정렬하거나 그룹핑 하기 위해서

### if) index를 걸지 않는다면?

```
SELECT *
FROM customer
WHERE first_name = "yerin";
```

원하는 데이터를 찾고 싶을 때 table 전체를 `full scan` 해야 한다.

즉, first_name에 index가 걸려있지 않다면 “yerin"을 찾기 위해서는 모든 데이터를 하나씩 확인해야 한다.

> full scan(=table scan) : row를 하나하나씩 모두 확인하는 것을 의미
> 
> 
> `시간복잡도` : **O(N)**
> 

full scan은 시간이 오래 걸리기 때문에 서비스에 좋지 않은 영향을 끼친다.

### index가 걸려있다면?

> 시간복잡도 : O(logN) (B-tree based index)
> 

full scan보다 더 빨리 찾을 수 있다.

<aside>
💡 Full scan이 더 좋은 경우

- table에 데이터가 조금 있을 때
- 조회하려는 데이터가 테이블의 상당 부분을 차지할 때

(full scan할지 여부는 optimizer가 판단함)

</aside>

## Index 생성 방법

1. 이미 테이블에 생성되어있을때

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%201.png)

- 첫번째 쿼리문에서는 name은 중복이 가능하기에 UNIQUE (X)
- 두 번째 쿼리문의 index는 player 테이블에 각 데이터를 유니크하게 식별할 수 있어 UNIQUE INDEX로 생성
    
    (이때 두개 이상의 attr로 구성된 Index를 multi column index라고 한다.)
    

1. 테이블 생성하면서 인덱스 걸 때

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%202.png)

- CREATE는 쓰지 않아도 됨.
- 대부분의 RDBMS는 primary key에는 index가 자동으로 생성됨.

## Index 자료구조

1. Hash table

해시 테이블은 키(Key)와 해시 값(Hash Value) 쌍으로 이루어진 자료구조이다. 

해시 테이블의 검색 방식은 키를 해시 함수를 사용하여 해시 값으로 변환한 후, 해당 해시 값에 해당하는 값을 찾아서 검색한다. 

- O(1)의 시간복잡도를 가지고 있어 상당히 빠른 검색을 할 수 있다.
- 데이터의 분포에 따라 충돌이 발생할 수 있다.
- 등호(=) 연산에만 특화되어 있어 부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않다.

2. B-Tree

가장 널리 사용되는 인덱스 자료구조 중 하나이다.  

B-Tree는 균형 잡힌 이진 검색 트리로 데이터베이스에서 검색 속도를 높이기 위해 사용된다.

- O(logN)의 시간 복잡도를 가지고 있다.
- B-Tree의 각 노드 내 데이터들은 항상 정렬된 상태인 것이 특징이며, 데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가진다.
- 한 노드에서 여러 개의 키를 가질 수 있고, 키에 해당하는 데이터도 함께 갖고 있다.

3. B+Tree

B+Tree는 B-Tree의 변형된 구조로, B-Tree에 비해 더 많은 키를 가질 수 있다.

- B+Tree의 모든 데이터는 단말 노드에서만 저장되고, 내부 노드에는 검색을 위한 인덱스만 저장된다.
- 모든 리프 노드가 연결 리스트로 연결되어 있으며, 순차적으로 저장되어 있다.
    
    ⇒ 범위 검색(Range Search)이나 순차 검색(Sequential Search)에 효율적
    

### 인덱스 B Tree로 구현되는 이유

데이터 검색을 할 때 hash table의 시간복잡도는 O(1)이고 B+tree는 O(log n)으로 더 느린데 왜 index는 hash table이 아니라 B+tree로 구현되나요?

⇒

Hash table을 사용하면 하나의 데이터를 탐색하는 시간은 O(1)으로 B+tree보다 빠르지만, 값이 정렬 되어 있지 않기 때문에 부등호를 사용하는 query에 대해서는 매우 비효율적이게 되어 데이터를 정렬해서 저장하는 B+tree를 사용한다. 데이터 탐색뿐 아니라 저장, 수정, 삭제에도 항상 O(long n)의 시간 복잡도를 갖는다.

# 📌B tree & B+tree

## B tree

데이터가 정렬된 상태로 유지되어 있는 트리로 한 노드 당 자식 노드가 2개 이상 가능한 트리.

어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있는 것이 장점.

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_b_tree_b+tree_1.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_b_tree_b+tree_1.png)

한 개의 데이터 : 노드(node)

가장 상단의 노드 : 루트 노드(root node)

중간 노드 : 브랜치 노드 (branch node)

가장 아래 노드 : 리프 노드(leaf node)

### 특징

1. 균일성 : 어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다.
    
    (시간복잡도 : O(logN))
    
2. 균형트리 : 루트 - 리프 거리가 일정한 트리 구조. 성능이 안정화 되어 있음. (모든 리프 노드들은 같은 레벨에 있다.)
    
    (처음 생성 당시는 균형 트리이지만 갱신이 반복되면 서서히 균형이 깨지고, 성능도 약화 됨.
    
3. 항상 정렬된 상태로 부등호 연산에 문제가 없다.

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_b_tree_b+tree_2.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_b_tree_b+tree_2.png)

데이터와 데이터 사이의 범위를 이용하여 자식 노드를 가리킨다.

노드 내 데이터들은 항상 정렬된 상태. 각 노드는 여러 개의 key를 가지고 있고 각 key에 대응하는 data도 가지고 있다.

### 삽입

- 추가는 항상 리프노드에 한다
- 노드가 넘치면 가운데 key를 기준으로 좌우 key들은 분할하고 가운데 key는 승진한다.
- m차 b 트리일때 최대 키값은 m-1
- 오름차순으로 정렬되도록 추가해야한다.

ex) 3차 b tree 데이터 삽입

최대 3개의 자녀 노드를 가질 수 있고, 최대 키값은 3-1=2이다.

20 삽입

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%203.png)

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%204.png)

노드가 넘침 ⇒ 좌우 키(20과 90) 분할하고 가운데 키(30) 승진

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%205.png)

부모 노드에서 또 노드가 넘침 ⇒ 2와 30 분할 & 15 승진

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%206.png)

### 삭제

- 삭제도 항상 리프노드에서 발생한다
- 삭제 후 최소 key수보다 적어졌다면 재조정한다

최소 key수 : [m/2]-1 (3차일때는 1)

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%207.png)

5를 삭제했더니 key수가 0이 됨. ⇒ 재조정 필요

**재조정**

1. key수가 여유있는 형제의 지원을 받는다.

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%208.png)

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%209.png)

1. 1번이 불가능하면 부모의 지원을 받고 형제와 합친다.
    
    ![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2010.png)
    
2. 2번 후 부모에 문제가 있다면 거기서 다시 재조정한다.

2삭제 후 1삭제 진행중 부모에도 문제 발생 ⇒ 재조정 필요

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2011.png)

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2012.png)

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2013.png)

### internal 노드 (리프노드 제외한 노드) 데이터 삭제

- 리프노드에서 삭제하고 필요하면 재조정
- internal 노드에 있는 데이터를 삭제하려면 leaf 노드에 있는 데이터와 위치를 바꾼 후 삭제한다.
    
    (이때 삭제할 데이터의 선임자 or 후임자와 위치 바꿈)
    

15와 9(선임자) 위치 변경 후 15 삭제

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2014.png)

![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2015.png)

---

## B+tree

B tree를 확장한 것으로 리프노드에만 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 key만을 갖는다.

### 특징

1. 오직 리프노드에만 데이터 저장 가능
2. 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메모리를 더 확보함으로써 더 많은 key들을 수용할 수 있다. 
3. 중복된 키를 가질 수 있다.
4. 리프 노드끼리 연결리스트로 연결되어 있다.
5. 풀 스캔 시, B+tree는 리프노드에 데이터가 모두 있기 때문에 한 번의 선형탐색만 하면 돼서 B tree에 비해 빠르다.

### 삽입

**(1) key의 수가 최대보다 적은 leaf node에 삽입하는 경우 (노드 안 넘칠 때)**

- 해당 노드의 가장 앞이 아닌 곳에 삽입되는 경우 단순히 삽입
- 가장 앞에 삽입되는 경우, 삽입 후 부모 key를 삽입된 key로 갱신하고, data를 넣어줌

**(2) key의 수가 최대인 leaf node에 삽입하는 경우( 노드 넘침)**

key의 수가 최대이므로 분할 필요!

- 중간 node에서 분할이 일어나는 경우는 B tree와 동일함.
- 리프노드에서 분할이 일어나는 경우
    
    중간 key를 부모 node로 올려주는데 이때, 오른쪽 node에 중간 key를 붙여 분할한다. 
    
    그리고 분할된 두 노드를 연결리스트로 연결한다.
    
    ![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2016.png)
    
    ![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2017.png)
    
    ![Untitled](DB%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%2098ba34ed1bc34e23be38cd48a3361bac/Untitled%2018.png)
    

### 삭제

(1) 삭제할 key가 리프노드의 가장 앞에 있지 않은 경우

B tree와 동일하다.

(2) 삭제할 key가 리프노드의 가장 앞에 위치한 경우

리프노드가 아닌 노드에 key가 중복해서 존재한다. 해당 key를 노드보다 오른쪽에 있으면서 가장 작은 값으로 바꿔줘야 한다.

![https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_b_tree_b+tree_13.png](https://github.com/devSquad-study/2023-CS-Study/raw/main/DB/img/db_b_tree_b+tree_13.png)

- 질문
    
    # **인덱스가 성능에 미치는 영향**
    
    ### **긍정적인 영향**
    
    1. **검색 속도 향상:** 인덱스를 사용하면 데이터 검색과 조회 작업이 빨라집니다.
    2. **정렬 및 그룹화 작업 최적화:** 인덱스가 적용된 컬럼을 기반으로 정렬(`ORDER BY`)이나 그룹화(`GROUP BY`)를 할 때 성능이 향상됩니다.
    3. **조인 성능 향상:** 인덱스를 사용하여 다른 테이블과의 조인(Join) 작업이 최적화됩니다.
    
    ### **부정적인 영향**
    
    1. **인덱스 관리 비용:** 인덱스를 생성하고 유지하기 위해 추가적인 저장 공간이 요구됩니다.
    2. **데이터 변경 성능 저하:** 삽입(`INSERT`), 삭제(`DELETE`), 수정(`UPDATE`) 작업 시 인덱스의 재구성이 필요하여, 이로 인한 성능 저하가 발생할 수 있습니다.