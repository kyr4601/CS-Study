# OS 2주차

# 프로세스 동기화

## 0️⃣프로세스 동기화

여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일등을 **공유자원**이라고 한다. 공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있다. 

이러한 문제를 우리는 **race condition**이라고 한다.

> 여러 프로세스(또는 스레드)가 공유자원에 동시에 접근할 때 공유자원에 대한 접근 순서에 따라 실행 결과가 달라질 수 있는 상황으로, 동시에 접근할 때 자료의 일관성을 해치는 결과가 나올 수 있다.
> 

따라서 프로세스들의 **공유 자원 접근 순서**를 정하여 예상치 못한 문제가 발생하지 않도록 해야한다. 

<aside>
💡 **프로세스 동기화**
여러 프로세스/스레드가 동시에 실행해도 공유 자원의 일관성을 유지하는 것

</aside>

## 1️⃣Critical Section

### HOW?

**Critical Section Problem**을 해결하면 돼!

> ***critical section (임계구역)***
여러 프로세스 또는 스레드가 동시에 접근하면 문제가 발생할 수 있는 코드 영역. 공유 자원에 대한 실질적인 데이터 조작이 이루어지는 부분으로, 이 영역에 들어가면 해당 자원에 대한 접근이 보호되어야 한다.
> 

Critical Section Problem은 다중 프로세스 또는 다중 스레드가 공유 자원에 동시에 접근할 때 발생할 수 있는 문제

각 프로세스는 자신의 **임계 구역**으로 진입하려면 **진입 허가**를 요청해야 한다. 이러한 요청을 구현하는 코드 부분을 **진입 구역(entry section)**이라고 한다. 임계 구역 뒤에는 **퇴출 구역(exit section)**이 따라올 수 있으며, 코드의 나머지 부분들은 총칭하여 **나머지 구역(remainder section)**이라고 부른다.

![https://blog.kakaocdn.net/dn/tmzqd/btrujIiyrAe/0bQpBnO31sqprMFuV2iZ91/img.png](https://blog.kakaocdn.net/dn/tmzqd/btrujIiyrAe/0bQpBnO31sqprMFuV2iZ91/img.png)

### CSP의 해결책이 되기 위한 조건

1. mutual exclusion 상호 배제
    
    한 프로세스가 현재 Critical Section에 있을 때 다른 프로세스는 접근할 수 없다.
    
    (한번에 하나의 프로세스/스레드만 실행)
    
2. progress 진행
    
    Critical Section에 있는 프로세스가 없으면 다른 프로세스가 Critical Section에 들어가게 해야 한다.
    
    (계속 진행이 되도록 해야 함)
    
3. bounded waiting 한정된 대기 
    
    프로세스가 Critical Section에 들어가려고 시도한 후에 허용되기까지 기다리는 시간이 제한되어야 한다.
    
    (어떤 프로세스/스레드가 무한정 대기하게 두면 안 됨)
    

## 2️⃣해결 방법(동기화 기법)

# 스핀락과 뮤텍스는 같은 개념으로 .

### Lock이란?

> 공유 자원을 특정 스레드가 사용하고 있을 때, 다른 스레드는 해당 공유 자원에 접근할 수 없도록 제한하는 것
> 

![Untitled](OS%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fb010dc892334b9a9ae308277eb7c20f/Untitled.png)

스레드 A가 접근하면 공유 자원에 락을 걸어 스레드 B가 접근하지 못하게 만든다. 스레드 A의 작업이 종료되면 락을 풀고 ( = release = unlock) 대기(wait) 중이던 스레드 B가 작업을 수행하게 만든다.

이렇게 스레드를 순차적으로 실행하게 만들면 공유 자원의 동기화를 구현할 수 있다. 

### 스핀락

> 스레드가 락을 얻을 때까지 무한 루프를 돌며 확인하는 동기화 매커니즘
> 

![Untitled](OS%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fb010dc892334b9a9ae308277eb7c20f/Untitled%201.png)

먼저 스레드가 실행되는 동안 (= CPU를 점유하는 동안) 공유 자원에 락을 걸고, 스레드의 작업이 종료되면 락을 해제한다. 따라서 다음 스레드가 CPU를 차지하기 위해선 공유 자원에 락이 걸렸는지 걸리지 않았는지를 파악하는 과정이 필요하다.

스핀락은 대기 중인 스레드가 공유 자원의 상태를 무한 루프를 이용해 확인하는 방식이다. 락이 걸려있으면 작업하지 못하고, 락이 걸려있지 않다면 작업할 수 있으니 그냥 무작정 반복적으로 Lock이 반환될 때까지 확인하며 대기하는 것이다.

단점

1. Busy waiting : 스핀락의 획득을 위해 CPU의 오버헤드가 발생할 수 있다. (무한루프를 돌면서 CPU를 계속 사용함)
2. Starvation (기아 상태) : 특정 스레드나 프로세스가 공유 자원을 오랫동안 점유한다면, 다른 스레드들이 대기 상태에 갇힐 수 있다.

언제 쓰지?

💡 스핀락은 스레드나 프로세스의 경합 상황이 짧을 때 ( = 임계 구역에서의 작업이 빠르게 이루어질 때) 유용하다.

⇒ 스핀락의 무한 루프 덕분에 락의 획득과 반환이 빨라 실행 속도도 빨라지고, 문맥 교환이 생략되기에 CPU의 오버헤드도 줄어든다.

💡 스핀락은 여러 개의 CPU 코어가 존재할 때 유용하다.

⇒ 사용하지 않는 CPU 코어에서 스핀락을 통해 대기하다가 바로 락을 획득할 수 있다. 

### 뮤텍스

> 하나의 스레드가 락을 얻어 critical section에 진입했다면, 락을 취득하지 못한 다른 스레드는 락을 가질 수 있을 때까지 휴식하는 방식
> 

뮤텍스는 wait와 signal이라는 원자적 연산을 사용한다.

다음은 뮤텍스를 사용하여 상호 배제를 구현한 예

```arduino
do {
  wait (mutex);

    // Critical section

  signal (mutex);

    // Remainder section
} while (TRUE);
```

잠금 메커니즘이라는 점은 스핀 락과 동일하나 권한을 획득할 때까지 busy waiting 상태에 머무르지 않고

sleep 상태로 들어가고 wakeup 되면 다시 권한 획득을 시도하는 sleep lock을 사용한다.

### 세마포어

> 공유자원에 대한 접속을 제어하기 위해 최대 허용치만큼 접근 요청을 가능하게 하여 카운트를 세서 카운트가 0이 되면 대기하도록 하는 기법
> 

![Untitled](OS%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fb010dc892334b9a9ae308277eb7c20f/Untitled%202.png)

카운팅 세마포어의 예시

유한한 개수를 가진 자원에 대한 접근을 제어하는데 사용할 수 있다. 다른 방법으로 이진 세마포어도 있는데 초기값을 0 또는 1만 가질 수 있는 세마포어이다. (뮤텍스와 유사함)

세마포어에 대해 이해하기 위해서는 wait(), signal(), 0에 대해 이해해야한다. 각 자원을 사용하려는 프로세스는 세마포어에 wait() 연산을 수행하고 세마포어의 값은 감소하게 된다. 프로세스가 자원을 방출 할 떄는 signal() 연산을 수행하고 세마포어는 증가하게 된다. 그리고 세마포어의 값이 0이 되면 모든 자원이 사용중임을 나타내고 이후 자원을 사용하려는 프로세스는 세마포어 값이 0보다 커질때까지 봉쇄된다. 

뮤텍스 vs 세마포어

- 세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스(or 스레드)가 접근할 수 있다. 반면 뮤텍시는 오직 1개만 접근 가능
- 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있다. 하지만 뮤텍스는 락을 획득한 프로세스가 반드시 그 락을 해제해야한다.

## 3️⃣IPC

프로세스의 가장 큰 특징은 **독립된 메모리 공간을 할당 받는다**는 것이다. 

그렇다면 독립적으로 메모리 공간을 할당 받는 프로세스들이 **어떻게 상호 간 통신을 할까?**

⇒ 커널에서 제공하는 IPC를 통해 서로 다른 프로세스들끼리 통신을 한다. 

> IPC (=Inter process Communication)는 프로세스들 사이에 서로 데이터를 주고 받는 행위 또는 그에 대한 방법이나 경로를 말한다.
> 
- IPC 없이는 프로세스 간 통신이 어렵기 때문에 커널에서 IPC라는 내부 프로세스 간 통신 기능을 제공한다.

그리고 이러한 IPC 통신 기법은 크게 두 가지로 분류된다.

하나는 **Shared memory(공유 메모리)** 이고, 다른 하나는 **Message passing(메시지 전달)** 이다. 

---

### Shared Memory

프로세스 간 공유된 메모리를 생성하여 이용하는 것

![https://user-images.githubusercontent.com/84573261/223031904-f818f68f-f141-444f-8f19-c5ab5965c1c3.png](https://user-images.githubusercontent.com/84573261/223031904-f818f68f-f141-444f-8f19-c5ab5965c1c3.png)

공유 메모리를 이용한 프로세스들은 공유 메모리를 우선 생성하여 해당 메모리에서 데이터를 공유하며 통신한다. 

프로세스가 공유 메모리를 생성하여 동작하기까지의 작동 과정은 다음과 같다.

1. 프로세스가 커널에게 공유 메모리 할당을 요청한다.
2. 커널은 해당 프로세스에 메모리 공간을 할당한다 (= 공유 메모리).
3. 공유 메모리가 설정되면 그 이후에는 커널의 관여 없이 통신이 가능해진다. 즉, 공유 메모리를 통해 프로세스가 통신을 하는 것이다.

장점 → **커널의 관여 없이 통신하므로 IPC 통신 속도가 상대적으로 빠르다**

커널은 프로세스 간 통신을 위해 메모리 공간을 할당해주기만 할 뿐, 프로세스가 공유 메모리를 통해 통신을 할 때 직접적으로 관여하지 않는다. 그렇기 때문에 커널을 거치지 않고 통신하므로 IPC 통신 속도가 빠르다는 장점이 있다.

단점 → **커널의 개입이 없기 때문에 커널이 제공하는 동기화 작업을 받지 못한다**

그렇기 때문에 프로세스의 동시적인 접근을 직접 제어해야 한다는 단점이 있다.

---

### Message Passing

프로세스들이 **커널을 통해 메시지를 전달**하는 방식

![https://user-images.githubusercontent.com/84573261/223035243-75edada9-4fb8-40f7-96ad-d5aa64abc582.png](https://user-images.githubusercontent.com/84573261/223035243-75edada9-4fb8-40f7-96ad-d5aa64abc582.png)

메시지 전달은 커널을 경유하여 메시지를 전달하는 방식을 말한다. 

프로세스가 커널에게 데이터를 보내면 (=send), 다른 프로세스는 커널에게 해당 데이터를 받는다 (=receive)

메시지 전달의 예시는 파이프 (pipe), 메시지 큐 (message queue), 소켓 (socket) 등이 있다.

장점 → 메시지 전달 방식은 프로세스가 데이터를 주고 받을 때 커널에서 제어해주기 때문에 **별도의 동기화가 필요 없다**

- 더 정확히 말하자면, 커널은 send, receive 연산에 대해 동기화를 제공한다.

단점 → 메시지 전달은 **커널을 경유하기 때문에 속도가 상대적으로 느리다**

# 교착 상태

## 0️⃣데드락

두 개 이상의 프로세스 혹은 스레드가 서로가 가진 리소스를 기다리는 상태

![Untitled](OS%202%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fb010dc892334b9a9ae308277eb7c20f/Untitled%203.png)

### 데드락 발생 조건

1. mutual exclusion 
    
    리소스를 공유해서 사용할 수 없다
    
2. hold and wait
    
    프로세스가 이미 하나 이상의 리소스를 취득(hold)한 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다린다(wait)
    
3. no preemption
    
    리소스 반환은 오직 그 리소스를 취득한 프로세스만 할 수 있다
    
4. circular wait
    
    프로세스들이 순환 형태로 서로의 리소스를 기다린다
    

[https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28](https://t1.daumcdn.net/cfile/tistory/243E89355714C26E28)

프로세스1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자

t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음

t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림

현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐

→ 이것이 바로 **DeadLock**

## 1️⃣데드락 해결 방법

### 1. 데드락 예방

4가지 조건 중 하나가 충족되지 않게 시스템을 디자인

- **mutual exclusion** 부정
    - 여러 프로세스가 리소스를 공유하게끔 하는 것
    
    (mutual exclusion이 보장되어야하는 리소스들이 있어서 사실상 어려움)
    
- **hold and wait** 부정
    - 사용할 리소스들을 모두 획득한 뒤에 시작
        - 리소스 활용 효율 저하
        - 기아현상 발생 가능
    - 리소스를 전혀 가지지 않는 상태에서만 리소스 요청하도록 제약조건 생성
- **no preemption** 부정
    - 리소스 점유 중인 프로세스가 다른 리소스를 요청할 때 가진 리소스 반납
- **circular wait** 부정
    - 리소스에 고유번호 할당 후 순서대로 리소스 요청
    

### 2. 데드락 회피

실행 환경에서 추가적인 정보를 활용해서 데드락이 발생할 것 같은 상황을 회피하는 것

`**Banker Algorithm`** 

리소스 요청을 허락해줬을 때 데드락이 발생할 가능성이 있으면 리소스를 할당해도 안전할 떄까지 계속 요청을 거절하는 알고리즘

- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
- 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기

⇒실효성이 적어서 잘 못 쓴다! (모든 상황에 들어맞을만한 정확한 규칙을 정해놓을 수가 없음)

### 3. 데드락 회복

데드락을 허용하고 데드락이 발생하면 복구하는 전략

- 프로세스 종료 방법
    - 교착 상태의 프로세스를 모두 중지
    - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
- 자원 선점 방법
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점
    

[ 세마포어(Semaphore) vs 뮤텍스(Mutex) 차이 ]

세마포어
리소스에 동시 허용이 가능한 스레드의 수를 제어하는 데 사용됨

소유 권한이 없으므로, 잠금을 획득하지 않은 쓰레드도 signal 연산을 사용하여 잠금을 해제할 수 있음

초기 값을 설정할 수 있으며, 이 값은 허용 가능한 동시 액세스 수를 나타냄wait (P)와 signal (V) 연산을 통해 제어됨

뮤텍스
임계 영역을 보호하여 데이터 무결성을 보장하기 위해 사용됨

소유 권한을 가지므로, 잠금을 획득한 쓰레드만 잠금을 해제할 수 있음

주로 이진 세마포어(Binary Semaphore)로 초기화되며, 두 가지 상태(잠금 상태와 잠금 해제 상태)만 가짐

lock과 unlock 연산을 통해 제어됨

acquire(), release()

프로그램 실행시켜서 hello world 입력시 컴퓨터 내부에서 어떤 일이 발생하나요? 

유저모드 hello world 입력

컨텍스트 스위칭 

커널모드 전환 -