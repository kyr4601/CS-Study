# OS 1주차

프로그램 : 컴퓨터가 실행할 수 있는 명령어들의 집합

프로세스 : 컴퓨터에서 실행중인 프로그램

CPU : 명령어를 실행하는 연산장치

메인 메모리 : 프로세스가 CPU에서 실행되기 위해 대기하는 곳

IO : 파일을 읽고 쓰거나 네트워크의 어딘가와 데이터를 주고받는것 (입출력 장치와 데이터를 주고받는것)

# 운영체제란?

## 0️⃣운영체제란?

**운영체제(OS, Operating System)**는 컴퓨터 시스템의 핵심 소프트웨어로, 컴퓨터 하드웨어와 응용 프로그램 간의 상호작용을 관리하고 제어하는 역할을 한다.

**운영체제의 목적**은 **사용자와 하드웨어 사이의 인터페이스를 제공해 효율적으로 응용 프로그램이 동작하도록 지원**하고, **시스템 자원을 효율적으로 관리하여 응용 프로그램이 원활하게 동작**할 수 있도록 한다.

운영체제의 코어(핵심) 부분을 **`커널(Kernel)`**이라고 하는데, 일반적으로는 커널에 여러가지 기능(라이브러리, 시스템 프로그램 등등)이 추가된 상태를 통칭해서 운영체제(OS)라고 한다.

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled.png)

### **운영체제의 역할**

- **① 자원 관리**
    
    운영체제는 컴퓨터 시스템의 하드웨어 자원을 효율적으로 관리하는 역할을 한다. CPU(중앙처리장치), 메모리(Memory), 저장장치(Storage), 입출력 장치(I/O Device) 등 하드웨어의 자원을 할당하고 관리하여 여러 응용 프로그램이 동시에 실행될 수 있도록 한다.
    
- **② 메모리 관리**
    
    운영체제는 컴퓨터의 메모리를 효율적으로 관리하여 응용 프로그램이 필요로하는 메모리 공간을 할당한다. 여기서 메모리의 할당과 해제, 가상 메모리 관리 등을 포함한다.
    
- **③ 프로세스 관리**
    
    운영체제는 실행 중인 응용 프로그램인 프로세스(Process)를 관리한다. 여기서 프로세스의 생성, 실행, 일시 정지, 시스템 중지 등의 작업을 제어하며, 여러 프로세스 간의 자원 공유와 협력을 관리한다.
    
- **④ 디스크 및 파일 시스템 관리**
    
    운영체제는 디스크와 파일 시스템을 관리하여 파일의 생성, 삭제, 복사, 이동 등의 작업을 처리한다. 파일 시스템은 데이터의 영구적인 저장과 접근을 제공하여 사용자 및 응용 프로그램이 데이터를 쉽게 관리할 수 있도록 한다.
    
- **⑤ 입출력 관리**
    
    운영체제는 입출력 장치와의 상호작용을 관리한다. 사용자와 응용 프로그램이 키보드, 마우스, 디스플레이, 프린터 등과의 통신을 할 수 있도록 지원하며, 입출력 장치의 성능을 최적화 한다.
    
- **⑥ 사용자 인터페이스**
    
    운영체제는 사용자와 컴퓨터 간의 상호작용을 지원하는 사용자 인터페이스를 제공한다. 텍스트 기반의 터미널 환경(CLI, Command Line Interface)과 그래픽 사용자 환경(GUI, Graphical User Interface)을 통해 사용자가 컴퓨터를 조작할 수 있도록 한다.
    
- **⑦ 네트워킹**
    
    운영체제는 컴퓨터 네트워크를 관리하고, 네트워크 프로토콜을 지원하여 컴퓨터 간의 통신을 가능하게 한다. 인터넷 연결, 데이터 전송, 네트워크 보안 등을 관리한다.
    
- **⑧ 오류 처리**
    
    운영체제는 시스템 내부 또는 외부에서 발생하는 오류와 예외 상황을 처리한다. 여기서 프로세스의 비정상 종료, 메모리 오버플로우, 입출력 오류 등을 감지하고 처리하여 시스템의 안정성과 신뢰성을 유지한다.
    
- **⑨ 시스템 보안**
    
    운영체제는 시스템의 보안을 유지하기 위해 접근 제어, 사용자 인증, 암호화 등의 기능을 제공한다. 여기서 불법적인 접근과 데이터 유출 등으로부터 시스템을 보호하고 안전한 환경을 제공한다.
    

## 1️⃣커널이란?

**커널**은 운영체제 중 항상 메모리에 올라가 있는 **운영체제의 핵심 부분**으로써 하드웨어와 응용 프로그램 사이에서 **인터페이스를 제공하는 역할**을 하며 **컴퓨터 자원들을 관리하는 역할**을 한다. 

다만 이러한 커널은 항상 컴퓨터 자원들을 바라만 보고 있기에 사용자와의 상호작용은 지원하지 않는다. 따라서 사용자와의 직접적인 상호작용을 위해 프로그램을 제공하게 되는데, 대표적으로 쉘(Shell)이라는 명령어 해석기 등이 있다.

컴퓨터와 전원을 켜면 운영체제는 이와 동시에 수행된다. 

소프트웨어가 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 한다. 

즉, 운영체제 자체도 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야한다.

하지만 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라가면 한정된 메모리 공간이 낭비가 심할 것이다. 따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 
이때 메모리에 상주하는 운영체제의 부분(항상 필요한 부분)을 kernel이라고 한다.

커널의 가장 큰 목표는 **컴퓨터의 물리적(하드웨어) 자원**과 **추상화 자원**을 관리 하는 것이다. 추상화란 물리적으로 하나뿐인 하드웨어를 여러 사용자들이 번갈아 사용할 수 있도록 마치 여러개처럼 보이게 하는 기술이다. 즉, 커널이 관리함에 따라 각 사용자들을 하나의 하드웨어를 독점하는 것처럼 느낄 수 있도록 한다. 

 물리적 자원 - 이를 추상화한 자원

- CPU - Task or Process
- 메모리 - Page or Segment
- 디스크 - File
- 네트워크 - Socket

**커널의 작업**

- Task(Process) Management : 물리적 자원인 CPU를 추상적 자원인 Task로 제공
- Memory Management : 물리적 자원인 메모리를 추상적 자원인 Page 또는 Segement로 제공
- File System : 물리적 자원인 디스크를 추상적 자원인 File로 제공
- Network Managment : 물리적 자원인 네트워크 장치를 추상적 자원인 Socket으로 제공
- Device Driver Management : 각종 외부 장치에 대한 접근
- Interrupt Handling : 인터럽트 핸들러
- I/O Communication : 입출력 통신 관리

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%201.png)

커널 구성요소들이 존재하는 공간을 Kernel Space라고 할 수 있다. 
Kernel Space 위에는 사용자로 여겨지는 User Space가 있으며 여기에는 Task, Process들이 존재한다. 이 User Space와 Kernel Space 사이에는 보이지 않지만 **System Call Interface**가 있다. User Space의 Task 또는 Process들이 커널이 관리하는 자원에 접근해야할 필요가 있을때 System Call Interface를 통해 Kernel Space의 자원관리자에게 요청이 전달되는 방식이다. 그렇게 되면 커널은 사용자요청에 맞는 하드웨어에게 명령을 전달하고 작업을 수행하는 역할을 한다.

즉, 결론적으로 **커널**은 사용자가 **System Call**을 통해 컴퓨터 자원을 사용할 수 있게해주는 **자원 관리자**라고 할 수 있다.

## 2️⃣시스템 콜이란?

OS는 다양한 서비스 들을 수행하기 위해 하드웨어를 직접적으로 관리한다. 이와 반면 응용 프로그램은 OS가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다. **OS가 제공하는 이러한 인터페이스를 `'시스템 콜 (system call)'`이라고 한다.**

### CPU 모드

CPU는 사용자 애플리케이션 (User application)이 시스템을 손상시키는 것을 방지하기 위해 2가지 모드를 제공한다. **CPU에 있는 Mode bit로 모드를 구분하여 0은  '커널모드(kernel mode)', 1은 '사용자모드 (user mode)'로 나뉘어서 구동**된다. 운영체제에서 프로그램이 구동되는데 있어서 파일을 읽어오거나, 파일을 쓰거나, 혹은 화면에 메세지를 출력하는 등 많은 부분이 커널 모드를 사용한다.

- **사용자 모드 (User Mode)**

사용자 모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O 등)에 접근할 수 없다. 접근을 위해서는 '시스템 콜(System Call)'을 사용해야 한다.

- **커널 모드 (Kernel Mode)**

운영체제(OS)가 CPU를 사용하는 모드이다. 시스템 콜을 통해 커널모드로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어(Privileged Instructions)를 실행한다. Privileged Instructions는 사용자 모드에서 실행되면 exception이 발생한다.

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%202.png)

***위 그림과 같이 사용자 process는 User Mode에서 실행되다가 시스템 자원을 사용해야할 때 시스템 콜을 호출해서 커널 모드로 전환되어 작업을 수행하고 완료 시 다시 사용자 모드로 전환한다.*** 

> 1. 유저모드에서 프로그램 실행
2. 프로그램 실행 중에 `**인터럽트**`발생 or `**시스템 콜**` 호출 ⇒  커널 모드로 전환
3. 커널모드는 프로그램의 현재 CPU 상태를 저장함 (나중에 이어서 실행할 수 있도록)
4. 커널이 인터럽트나 시스템 콜을 직접 처리함. (즉, cpu에서 커널 코드가 실행됨)
5. 처리 완료 후 중단됐던 프로그램의 CPU 상태를 복원. (3번에서 저장했던 거)
6. 통제권을 프로그램에게 반환하고 유저모드로 전환됨. 
7. 유저모드에서 프로그램이 이어서 실행됨.
> 

<aside>
💡 **결론은..**
프로그램이 운영체제 커널이 제공하는 서비스를 이용하고 싶을 때 **`시스템 콜`**을 통해 실행하고, 시스템 콜이 발생하면 해당 커널 코드가 커널 모드에서 실행된다.

</aside>

### 시스템 콜 종류

- 프로세스/스레드 관련
- 파일 I/O관련
- 소켓 관련
- 장치 관련
- 프로세스 통신 관련

## ❓

하드웨어 혹은 시스템 관련 기능은 어떤 프로그램이라도 반드시 시스템 콜을 통해서만 사용 가능한데 보통 우리는 개발할 때 직접  OS 시스템 콜을 사용한 적이 없음!

그럼에도 우리는 지금까지 파일 I/O, 네트워크 I/O, 프로세스/스레드 관련 작업을 해왔음.

어떻게 가능했던 걸까?

⇒ 프로그래밍 언어들이 시스템 콜을 래핑하여 간접적으로 사용할 수 있도록 해줌

JavaScript는? (node.js)

자바스크립트의 경우, 자바스크립트 엔진과 환경에 따라 다르게 동작합니다. 브라우저 환경에서는 웹 API(Web APIs)가 이 역할을 하며, 이는 브라우저가 제공하는 기능으로서 자바스크립트가 컴퓨터 시스템 자체와 직접 통신하는 것을 방지합니다.

반면에 Node.js와 같은 서버 사이드 환경에서는 libuv라는 라이브러리가 이 역할을 합니다. libuv는 비동기 I/O를 지원하는 멀티 플랫폼 C 라이브러리로, 파일 시스템 작업, 네트워킹 등과 같은 작업을 비동기적으로 처리할 수 있도록 돕습니다. 이를 통해 Node.js는 시스템 콜을 간접적으로 사용할 수 있게 됩니다.

## 3️⃣인터럽트란?

> 시스템에서 발생한 다양한 종류의 이벤트 혹은 그런 이벤트를 알리는 메커니즘
> 

인터럽트(Interrupt)는 **"방해하다, 중단시키다"** 의 의미를 가지고 있다. OS에서 인터럽트는 CPU가 현재 실행 중인 작업을 중단하고, 발생한 상황을 처리하는 기능이라고 할 수 있다.

인터럽트는 하드웨어와 소프트웨어에서 모두 발생할 수 있다. 

만약 현재 사용중인 노트북의 전원에 문제가 생긴 경우는 하드웨어에 의해 발생한 인터럽트이다. 만약 파일 READ/WRITE 프로그램을 작성하면 소프트웨어에 의한 인터럽트이다.

모든 시스템 콜은 인터럽트에 해당한다.

### 인터럽트 종류(발생할 때)

- 전원에 문제가 생겼을때
- i/o 작업이 완료됐을때
- 시간이 다 됐을 때
- 0으로 나눴을 때 - trap (프로그램 레벨에서 발생하는 인터럽트)
- 잘못된 메모리 공간에 접근을 시도할 때 - trap

<aside>
💡 `**인터럽트**`가 발생하면 CPU에서는 즉각적으로(실행중이던 명령어까지는 해결한 후에) 인터럽트 처리를 위해 커널 코드를 커널 모드에서 실행함.

</aside>

### 인터럽트 동작 원리

1. CPU에서 프로그램이 실행 중.
2. 인터럽트 발생
3. 현재 실행 중인 프로세스를 중단하고, 상태를 PCB에 저장한다.
4. 인터럽트를 처리한다.
4.1. 인터럽트가 발생한 장치를 식별한다.
4.2. 인터럽트를 처리할지 결정한다. 만약 처리하지 않으면 5번 과정으로 넘어간다.
4.3. 인터럽트 벡터 테이블에서 인터럽트 발생 원인에 따른 서비스 루틴을 실행한다. 
5. 중단된 프로세스가 실행된다. (단, 중단된 프로세스가 우선순위에 밀려 다른 프로세스가 실행될 수 있다.)

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%203.png)

# 프로세스 & 스레드

## 0️⃣프로세스

### 프로세스란?

⇒ **컴퓨터에서 실행중인 프로그램** 

- 각각의 프로세스는 독립된 메모리 공간을 할당 받음 .
- 스케줄링의 대상이 되는 작업(task)과 같은 의미로 쓰인다.
- 프로세스 내부에는 최소 하나의 스레드(thread)를 가지고있는데, 실제로는 스레드(thread)단위로 스케줄링을 한다.

### 프로세스의 메모리 구조

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%204.png)

- Code영역 : 실행할 프로그램의 코드가 저장됩니다. CPU는 이 영역에서 명령어를 하나씩 가져와 처리하게 됩니다.
- Data영역 : 전역변수와 정적변수가 저장됩니다. 이 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸됩니다.
- Stack 영역 : 지연변수, 매개변수, 리턴값 등 잠시 사용되었다가 사라지는 데이터를 저장하는 영역입니다. 함수 호출 시 할당되고 함수 반환 시 소멸됩니다.
- Heap영역 : 동적할당을 위한 메모리 영역. 메모리 주소 값에 의해서만 참조되고 사용되는 영역

### 프로세스의 상태

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%205.png)

**`new → ready`**

new 상태에서 프로세스가 생성되게 되면 OS 커널에 존재하는 Ready Queue에 올라가게됩니다.

**`ready → running`** 

Ready Queue에 있는 프로세스들을 OS가 위에서 말한 프로세스 스케줄링 알고리즘에 의해서 Running 상태로 가야할 프로세스를 CPU로 할당하게 됩니다. 그러면 프로세스가 Running 상태가 됩니다.

**`running → ready`**

현재 running 상태에 있는 프로세스A 보다 Ready Queue에서 대기하고 있는 프로세스 B가 우선순위가 높으면,  preemptive schedule(선점형)인 경우 프로세스A는 Ready 상태로 오게되고 프로세스B가 running 상태로 가서 CPU를 할당 받게됩니다.

대부분 멀티태스킹으로 이뤄지는 시스템에서 자신에게 할당된 TIME을 다 쓰게 되면 다시 ready상태로 가게 된다.

**`running → blocked`** 

현재 running 상태에 있는 프로세스A에서 입출력(I/O) 이벤트가 발생했을때 프로세스A가 blocked 상태로 가게됩니다.

**`blocked → ready`**

입출력(I/O)이벤트가 종료된 프로세스는 다시 Ready상태로 오게됩니다. (+ 그러다가 다시 스케줄러에 의해서 차례가 오면 running상태가 됨)

**`running → terminate`** 

프로세스 종료.

### 프로세스 생성

> 프로세스는 누가 만드는 걸까?
> 

프로세스는 부모 프로세스로부터 생성된다. 즉, 모든 프로세스는 부모 프로세스를 가진다. 부모-자식 관계이기 때문에 트리 자료구조로 관리된다. 모든 프로세스는 PID라는 고유 식별자를 가진다. PID는 PCB에 저장되어있다. 

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%206.png)

가장 위에 있는 ROOT 조상 프로세스는 Init process라고 불린다. 이는 컴퓨터 부팅시 마지막 단계에서 생성되고 PID는 1번이다. 

> 그러면 프로세스는 어떻게 만들어지는 걸까?
> 

1. **`fork()`**
fork()는 시스템 콜로 프로세스를 생성하는 명령어로, 부모 프로세스의 메모리 공간을 그대로 복사해 자식 프로세스에게 할당한다. 
    
    
    여기서 멈추면 그냥 부모 프로세스의 내용을 그대로 복붙한 자식 프로세스가 생기는 거고, 이러면 부모 프로세스와 똑같은 프로그램이 하나 더 실행되는 것과 다름이 없다. 
    
    즉, 내용은 같지만 일단 자식 프로세스라는 걸 생성하는 것까지는 fork()를 이용해 성공했다. 이제 자식 프로세스에게 새로운 프로그램을 대치시켜줘야한다.
    
2. **`exec()`**
    
    exec()는 시스템 콜로 메모리를 초기화하는 명령어로, 새로 생성된 자식 프로세스가 새로운 프로그램을 로드해서 메모리를 초기화한 뒤, 그 프로그램에 대한 프로세스를 시작하게 된다.
    
    exec()를 실행한 프로세스의 PID가 그대로 새로운 프로세스에 적용이 되며, 그 프로세스에 의해 기존 프로세스가 덮여 쓰여지게 된다. 
    
    즉, 프로그램에서 exec를 호출하면
    
    호출된 프로그램이 현재 메모리에 올라와 있는 프로그램을 덮어서 로딩되기 때문에 현재 메모리에 상주하고있던 프로그램은 무시되어 버린다. 
    
3. **`wait()`**
    
    부모 프로세스가 먼저 끝나면 자식 프로세스도 강제로 종료되는 문제를 방지하기 위해 wait()이라는 시스템 콜이 있다.
    
    ![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%207.png)
    

## 1️⃣스레드

실제로 컴퓨터에서 task로 사용하는 단위

**스레드는 프로세스 내부에서 실행되는 작은 작업 단위**이다. 

스레드는 한 프로세스(process)내부에 적어도 하나 존재합니다. 스레드가 여러개 존재하는 것을 멀티스레드라고 한다.
멀티스레드에서 각 스레드끼리는 프로세스의 일정 메모리 영역을 공유한다.

### 등장 배경

`**단일 프로세스 시스템**` ⇒ 한번에 하나의 프로그램만 실행

다른 프로그램 실행하려면 먼저 하던 거 끝내고 했어야 함

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%208.png)

🚨 CPU 사용률 안 좋음 

## ⬇️

**`멀티프로그래밍`** ⇒ 여러 개의 프로그램을 메모리에 올려놓고 동시에 실행

메모리에 올려놓고 작업을 해야할 때 해당 프로세스가 CPU에서 실행됨 

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%209.png)

🚨 CPU 사용시간이 길어지면 다른 프로세스는 계속 대기해야함

## ⬇️

**`멀티태스킹`** ⇒ 프로세스가 CPU를 사용할 때 아주 짧은 시간(Quantum)만 실행되도록 하자

사용자 입장에서는 진짜 여러 프로그램이 동시에 실행되는 것처럼 느껴짐

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%2010.png)

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%2011.png)

🚨 하나의 프로세스가 동시에 여러 작업을 수행하지는 못함

🚨 프로세스의 컨텍스트 스위칭은 무거운 작업

(컨텍스트 스위칭 - CPU에서 실행되기 위해 어느 한 프로세스에서 다른 프로세스로 교체되는것)

🚨 프로세스끼리 데이터 공유가 까다로움 (메모리가 공유되지 않는 분리된 메모리 공간 차지)

🚨 듀얼 코어가 등장했으니 이를 잘 활용하고 싶은데 그러진 못 함

## ⬇️

**`스레드`**  ⇒ CPU에서 실행되는 단위

- 프로세스는 **한 개 이상의 스레드**를 가질 수 있다.
- 같은 프로세스의 스레드들끼리 컨텍스트 스위칭은 가볍다.
- 스레드들은 자신들이 속한 프로세스의 메모리 영역을 공유한다.

**`멀티스레딩`** ⇒ 하나의 프로세스가 동시에 여러 작업을 실행하는데 목적

+확장된 멀티태스킹 개념

기존엔 프로세스만 짧게 쪼개서 썼는데 이제는

여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 CPU Time을 나눠갖는다.

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%2012.png)

**`멀티프로세싱`** ⇒ 두 개 이상의 프로세서나 코어를 활용하는 시스템으로 ****여러 개의 독립적인 프로세스가 동시에 실행되는 것이다.

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%2013.png)

- 한 코어에 여러 작업이 연결되어있으니 멀티태스킹 O
- 듀얼 스레드이기 때문에 멀티스레딩 O
- 듀얼 코어이기 때문에 멀티프로세싱 O

## 2️⃣ PCB & 컨텍스트 스위칭

### PCB란?

- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체이다.
- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요하다.
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.

<aside>
💡 **운영체제라는 프로그램이 프로세스를 하나 만들어서 실행을 하려면** 그 프로세스와 관련된 데이터 구조가 당연히 있어야 할 것이고, 프로세스가 뭔지 알아야 정말 기본적인 정보들은 어딘가에 저장이 되어 있어야 한다! 그곳이 바로 **PCB(Process control block)

ex) CPU에 긴급 프로세스 처리 요청이 들어오면 이전에 실행하던 프로세스를 어딘가에 저장해놔야함 ⇒ PCB**

</aside>

**PCB에 포함되는 정보**

- **Process ID** : 프로세스를 구분하는 **ID**
- **Process State** : 각 **State** 들의 **상태**를 저장한다.
- **Program Counter** : 다음 **Instruction** 의 **주소를** **저장하는 카운터**. CPU는 이 값을 통해 **Process 의 Instruction 을 수행**한다.
- **Register** : Accumulator, CPU Register, General Register 등을 포함한다.
- **CPU Scheduling Information** : **우선 순위, 최종 실행시간, CPU 점유시간 등이 포함(***)**된다.
- **Memory Information** : 해당 **프로세스 주소공간(lower bound ~ upper bound) 정보를 저장.**
- **Process Information**(페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등)
- **Device I/O Status**(프로세스에 할당된 입출력 장치 목록, 열린 팔린 목록 등)
- **Pointer** : **부모**/**자식** **프로세스에** 대한 **포인터**, **자원에** 대한 **포인터** 등
- **Open File List** : 프로세스를 위해 열려있는 파일의 리스트

### 컨텍스트 스위칭

CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정

⇒ CPU에서 실행중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것

**`WHAT?`**

프로세스/스레드의 상태 (cpu, 메모리 상태 등등)

**`WHY?`**

여러 프로세스/스레드를 동시에 실행시키기 위해서

**`WHEN?`**

- 주어진 time slice(quantum)를 다 사용했을 때
- IO작업을 해야할 때
- 다른 리소스를 기다려야 할 때

**`WHO?`**

OS커널

**`HOW?`**

다른 프로세스끼리 스위칭 ⇒ Process context switching

같은 프로세스의 스레드끼리 스위칭 ⇒ Thread context switching

둘의 공통점은?

1. 커널 모드에서 실행
2. cpu의 레지스터 상태를 교체

(cpu에는 여러 레지스터가 있고 이 레지스터는 각종 명령어들을 수행하기 위한 데이터를 저장하는 곳)

둘의 차이점은?

프로세스 컨텍스트 스위칭은 가상 메모리 주소 관련 처리를 추가로 수행 

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%2014.png)

즉, 스레드 컨텍스트 스위칭의 경우, 메모리 주소 관련 처리는 하지 않기 때문에 프로세스 컨텍스트 스위칭보다 더 빠르다.

# CPU 스케줄링

## 0️⃣프로세스 우선순위

프로세스에게는 PID라는 번호가 할당되어 관리된다.

여러 프로그램을 처리하기 위해서는 프로세스들에 우선순위를 부여해서 관리해야한다.

리눅스에서 ps -l 명령어를 통해 우선순위를 확인할 수 있다.

![Untitled](OS%201%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%204d6c58fb77f240bdb3949b0bcd8f3238/Untitled%2015.png)

프로세스에게 부여되는 PID와 부모프로세스 PPID 및 해당 프로세스를 실행시킨 사용자의 UID와 CMD(명령어)를 확인할 수 있다.

프로세스의 우선순위와 관련된 항목은 **PRI**와 **NI**번호이다.

PRI 번호

- 프로세스를 처리하는 운영체제가 참고하는 항목
- 사용자가 인위적으로 조작 불가능
- 시스템의 상황에 따라 적절하게 부여됨
- 낮은 값일수록 우선순위 높음

NI 번호

- 관리자와 사용자가 조작할 수 있는 우선순위 값
- 낮은 값일수록 우선순위 높음
- -20 ~ 19까지 설정 가능

## 1️⃣스케줄링 큐 관리

### 스케줄링이란?

> CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업 (자원을 어떤 프로세스에 얼마나 할당하는지 정책을 만드는 것)
선점형 스케줄링과 비선점형 스케줄링이 있음
> 

### 스케줄링 큐

스케줄링 큐에는 3가지 큐가 있다. 

job queue

ready queue

wait(or device) queue

`**job queue**`는 시스템 내에 있는 모든 프로세스의 집합이다.

**`ready queue`**는 실행될 준비를 하고 기다리는 프로세스 집합이다. 즉, 스케줄러에게 선택되어 CPU에 올라가기를 기다리는 프로세스들의 집합이다.

디스크는 다른 여러 프로세스들의 I/O 요청을 처리해야 해서 많이 바쁘고 속도도 느리다. 

프로세스가 I/O 요청을 했을 때, 디스크를 기다려야 한다.

이 때 특정 입출력 장치를 대기하는 프로세스는 **`device queue`**로 옮겨진다. 각 장치는 자신의 device queue를 가진다.

### Scheduler & Dispatcher

**`Scheduler` ⇒** CPU에서 실행될 프로세스를 선택하는 역할

CPU가 어떤 프로세스를 RUNNING하다가 종료 혹은 WAITING혹은 READY상태로 가게 되는데 이때 RUNNING상태가 멈추지 않도록 다음 일을 선택하는 일을 스케줄러가 한다.

**`Dispatcher` ⇒** 선택된 프로세스에게 CPU를 할당하는 역할

스케줄러에 의해 선택된 프로세스가 실제 CPU에서 실행될 수 있도록 만드는 작업을 한다.

ex) 컨텍스트 스위칭 / 커널모드 - 유저모드 전환 / 적절한 위치로 프로세스 이동

## 2️⃣스케줄링 선점 방식

### 선점형 스케줄링

하나의 프로세스가 CPU를 차지하고 있을 때,우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU를 점유하는 스케줄링 방식

- 응답이 빠름
- 적극적, 강제적
- 처리 시간 예측 어려움
- 높은 우선순위 프로세스들이 계속 들어오는 경우 오버헤드를 초래
- 실시간 응답환경 등 우선순위가 높은 프로세스를 빠르게 처리해야 할 경우 등에 유용

ex)

- 프로세스가 실행중인데 타임 슬라이스를 다쓰면 ready상태로 돌아가야하는데 이때 강제적으로 ready queue에 들어가게 될 때
- waiting상태에 있던 애가 ready가 됐는데 얘가 지금 실행되고 있는애보다 우선 순위가 높다면 얘를 running으로 보내고 원래 실행중이던 애는 ready로 끌고 내려오고 싶게 하고 싶을때

### 비선점형 스케줄링

한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식

 

- 응답이 느림
- 신사적, 협력적(cooperative)
- 모든 프로세스에 대한 요구를 공정하게 처리 가능
- 짧은 작업의 프로세스가 긴 작업 종료 시까지 대기해야할 수도 있다.
- 처리시간 편차가 적은 특정 프로세스 환경에 용이

ex)

- 프로세스가 자발적으로 running 상태에서 빠져나갈 때
- 다른 프로세스에게 양보하고 ready로 넘어갈 때

## 3️⃣스케줄링 알고리즘

- FCFS `비선점`
    
    먼저 도착한 순서대로 처리
    
- SJF (shortest-job-first) `비선점`
    
    수행시간이 가장 짧은 프로세스부터 실행
    
- Priority `비선점`
    
    우선순위가 높은 프로세스부터 실행
    
- SRTF(shortest-remaining-time-first) `선점`
    
    남은 수행시간이 가장 짧은 프로세스부터 실행
    
- RR(round-robin) `선점`
    
    time slice로 나눠진 CPU time을 번갈아가며 실행
    
- Multilevel queue `선점`
    
    프로세스들을 그룹화해서 그룹마다 큐를 두는 방식
    
    (각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여)
    

**SRT(Shortest Remaining Time) 스케줄링:** 짧은 시간 순서대로 프로세스를 수행한다. 남은 처리 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점됨. 아래에 소개할 SJF의 선점 버전이라고 할 수 있다.

**라운드로빈(Round-Robin)스케줄링:** 각 프로세스는 같은 크기의 CPU 시간을 할당 받고 선입선출에 의해 행된다. 할당시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 너무 커진다.

**다단계 큐(Multi-level Queue) 스케줄링:** Ready큐를 여러 개 사용하는 기법. 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여한다.

**SJF(Shortest Job First) 스케줄링:** 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행. 평균 대기 시간을 감소시킨다.

**우선순위(priority) 스케줄링:** 프로세스에게 우선순위를 정적, 혹은 동적으로 부여하여 우선순위가 높은 순서대로 처리한다. 동적으로 부여할 경우, 구현이 복잡하고 오버헤드가 많다는 단점이 있으나, 시스템의 응답속도를 증가시킨다.

 

⇒ 우선순위가 낮은 애들은 계속 연기되는 기아현상 문제가 발생할 수 있어서, 오랫동안 대기한 애들의 우선순위를 높여주는 에이징 기법을 사용해서 기아현상 문제를 해결할 수 있다. 

**FCFS 스케줄링:** 프로세스들은 Ready큐에 도착한 순서대로 CPU를 할당 받는다. 작업 완료 시간을 예측하기 매우 용이하다. 하지만 덜 중요한 작업이 중요한 작업을 기다리게 할 수도 있다.

멀티프로세스/ 멀티스레드를 사용하는 실제 예시

- **[프로세스와 쓰레드에 대해 설명하고, 둘의 차이에 대해 설명해주세요.](https://hoons-dev.tistory.com/95#%F-%-F%--%A-%--%ED%--%--%EB%A-%-C%EC%--%B-%EC%-A%A-%EC%--%--%--%EC%--%B-%EB%A-%--%EB%--%-C%EC%--%--%--%EB%-C%--%ED%--%B-%--%EC%--%A-%EB%AA%--%ED%--%--%EA%B-%A-%-C%--%EB%--%--%EC%-D%--%--%EC%B-%A-%EC%-D%B-%EC%--%--%--%EB%-C%--%ED%--%B-%--%EC%--%A-%EB%AA%--%ED%--%B-%EC%A-%BC%EC%--%B-%EC%-A%---)**
    
    
    **1) 프로세스**
    
    - 메인 메모리(주기억장치)에 적재되어 실행되는 프로그램을 의미합니다.
    - PCB, code, data, heap, stack 영역을 갖습니다.
    - 프로세스별 각각의 영역을 갖기 때문에 별다른 동기화 작업이 필요하지 않습니다.
    - 프로세스별 각각의 영역을 갖기 때문에 context switching 비용이 큽니다.
    - 프로세스 쓰레드보다 무겁기 때문에 생성 시간이 더 깁니다.
    - 한 프로세스에서 오류가 생기더라도 다른 프로세스에 영향을 주지 않습니다.
    
    **2) 쓰레드**
    
    - 한 프로세스 내의 실행 단위, 실행의 흐름을 의미합니다.
    - stack 영역만 별도로 갖고, 나머지 영역(code, data, heap)에 대해서는 해당 쓰레드를 포함한 프로세스의 자원을 공유합니다.
    - stack 영역 외부의 공유 자원에 대해 접근 시 동기화 작업이 필요합니다.
    - stack 영역 외부를 공유하므로 컨텍스트 스위칭 비용이 적습니다.
    - 쓰레드는 프로세스보다 가볍기 때문에 생성 시간이 더 짧습니다.
    - 한 쓰레드에서 오류가 생기면, 나머지 프로세스 내의 쓰레드에 영향을 줄 수 있습니다.
    

멀티프로세스와 멀티쓰레드는 리소스를 공유하는데 이에 대한 장단점을 말해라